
大家好，我叫 Nitesh，欢迎来到我的 YouTube 频道。在这个视频中，我们将继续我们的“使用语言图的Agentic AI”播放列表。今天的视频是这个播放列表的第四个视频。如果你还记得的话，在上一个视频中，我们做了一个非常详细的比较，比较了 LangChain 和 Lan Graph，在那里我还稍微介绍了一下LangGraph 是什么，它的核心能力是什么，以及什么时候你应该使用 LangChain。今天的视频将完全专注于 LangGraph。

在今天的视频中，我将要做的是向你们介绍LangGraph中的一些核心概念，这些概念你们在任何地方都能看到。我会让你们提前了解这些概念，这样你们就能轻松掌握所有概念，并实际将它们转换为代码。所以请务必看完这个视频到最后，如果可能的话，做好笔记。因为在实践之前，你们需要先通过预览了解一下LangGraph到底是什么。如果你们还记得上一个视频，我在那里详细比较了LangChain和LangGraph之间的区别，并在同一个过程中向你们解释了LangGraph是什么以及它的核心功能是什么。所以在我们开始之前，让我们先总结一下所有这些内容。

好的，如果用简单的语言来解释Lang Graph，它本质上是一个编排框架。这是什么意思呢？意思是如果你给Lang Graph一个LLM工作流程去执行，Lang Graph首先会尝试将该工作流程以图表的形式呈现出来，就像这样。这个图表的最大特点是什么？就是图表中的每个节点都代表你工作流程中的一个任务，明白吗？

现在LLM工作流中可以包含多种任务。一个任务可能是调用LLM，第二个任务可能是调用某个工具，第三个任务可能是做决策。那么Lang Graph在这里做了什么？它理解了你的工作流，然后将这个工作流转化为一个图的形式。这个图的构造方式是，每个节点都是你整个工作流中的一个子任务。最棒的是，所有这些节点都通过边相互连接。这些边告诉我们，在执行完某个特定节点或任务后，接下来应该执行哪个任务。简单来说，Lang Graph 为您提供了一个功能，通过这个功能，您可以将任何LLM工作流首先以流程图的形式呈现出来，然后还可以执行它。一旦您创建了这个图表，接下来您需要做的就是为它的第一个节点提供输入，并触发这个工作流或图表。然后会自动发生什么呢？所有节点将按照正确的顺序依次执行，您的工作流也就完成了。这里写的正是这一点：LangGraph是一个用于构建智能的编排框架。

有状态和多步骤的LLM工作流程。现在，LangGraph不仅仅局限于创建图表。它还为您提供了额外的功能，例如在这里，如果您愿意，可以执行并行任务，就像您在这里看到的那样，一个节点之后，接下来的两个节点将同时执行。如果您愿意，可以实现循环的概念，在这个节点之后，您可以返回到前面的节点，并且您可以在循环中完成这项工作。您还可以进行分支，在这个节点之后，根据某个条件，要么这个节点执行，要么那个节点执行。同时，您还可以获得内存的功能，即在这里执行的所有任务。

无论进行什么对话，您都可以记录下来，而且在这里您还会获得恢复功能，也就是说，如果某天某个任务中您的整个工作流程中断了，您可以从同一点恢复。因此，结合所有这些核心功能，可以说Langrath是构建代理和生产级AI应用的理想选择。好的，这就是我们在上一个视频中讨论的内容。如果您还没有观看上一个视频，我建议您去看一看。

因为在那里我们通过一个真实世界的用例来帮助理解为什么需要Langrath，我在那里向你们介绍了Langrath的7个核心功能，所以不可能再重复覆盖所有内容，但如果你们观看那个视频，一切都会变得清晰。所以现在既然你们已经了解Langrath是什么，接下来我们将逐一研究Langrath的一些核心概念，在学习了这些概念之后，你们将能够编写任何类型的工作流程。那么，首先我们要讨论的第一个概念是，

那就是LLM工作流程。刚才我向你们解释了定义Langrath的过程，提到Langrath是一个编排框架，借助它你可以构建任何类型的LLM工作流程，对吧？所以我认为我们需要稍微关注一下这个特定术语，即LLM工作流程到底是什么。首先，我们来谈谈工作流程是什么。你可以将工作流程定义为实现目标而执行的一系列任务。

例如，我们在上一个视频中看到的自动化招聘示例，我们需要执行一系列步骤来雇佣一个人。首先，我们需要创建职位描述，然后发布它，接着进行筛选，再进行面试，最后进行入职。只有当你按照正确的顺序执行这一系列步骤时，整个招聘流程才算完成。简单来说，你可以将工作流程视为一系列任务，通过按正确顺序执行这些任务来实现一个目标，这就是工作流程。那么，什么是LLM工作流程呢？LLM工作流程是一种工作流程，其中整个系列的任务中...

有很多任务都依赖于LLM（大型语言模型），比如我们之前提到的自动化招聘例子就是一个LLM工作流程。为什么呢？因为其中涉及多个需要LLM的任务环节：在撰写职位描述的流程中会用到LLM，在筛选候选人的流程中可能需要LLM，在面试环节中也可能需要使用LLM。简而言之，任何在执行阶段运用LLM的工作流程，我们都可以称之为LLM工作流程。

好的，看看这里，我已经写了一些东西，你可以浏览一下。LLM工作流程是一个逐步的过程，通过它我们可以构建复杂的LLM应用程序。工作流程中的每一步执行一个独特的任务，比如提示、推理、工具调用、内存访问或决策制定，对吧。而且工作流程可以是线性的、并行的、分支的或循环的，允许复杂的行为，如重试、多代理通信或工具增强推理。好的，所以我真的希望你能对LLM工作流程是什么有一点概念。现在说实话，每个应用程序都会有自己独特的工作流程，对吧。

你的自动招聘会有不同的工作流程，去自动化呼叫中心会有不同的工作流程，所以工作流程总是不同的。但有一些工作流程，你会在不同的地方看到，这些是常见的工作流程。那么，我来告诉你一些常见的工作流程，你会在很多地方看到它们。在这个特定的语言图谱播放列表中，我也会为你展示这些常见的工作流程，好吗？那么，让我们开始吧，从第一个常见的工作流程开始，这是最常见的LLM工作流程。

它的名字叫Prompt Chaining，在LLM的世界里是一个非常常见的工作流程，到处都能看到。基本上，你做的事情就是多次与LLM对话或调用LLM，就像你在这个流程图中看到的那样。在整个工作流程中，你一次、两次、三次地与LLM按顺序对话。这种工作流程的一个例子可能是，假设你正在开发一个应用程序，用户会给你一个主题名称，你需要基于该主题撰写一份详细的报告。现在你不能直接从主题开始写详细报告，相反，你会怎么做呢？你会把整个任务分解开来。首先，你会做什么？你会根据主题准备一个提纲，然后借助提纲来准备报告。所以现在你在做什么呢？你在某种程度上是在进行提示链式操作。你的主题来了，你在进行提示链式操作，将你的主题发送给第一个LLM，并告诉它绘制大纲。当大纲绘制完成后，你再将大纲发送给第二个LLM，并告诉它基于这个大纲打印一份详细报告。这样你就使用了提示链的概念，适用于处理复杂任务时。

你想把任务分成子任务吗？而且好处是，在整个过程中，你可以时不时地加入检查点，看看你的流程是否正常运行。比如在这里你可以看到，我们在这个LLM调用的输出上设置了一个检查点。在我们的用例中，一个检查点可能是我们的报告不应超过5000字。如果超过5000字，我们就会退出。这是一个非常常见的工作流程，你会在很多地方看到。我真的希望你已经理解了提示链。第二个是非常著名的LLM工作流程，我们称之为路由。

那么路由中发生的情况是，你基本上理解一个任务，然后决定由谁来执行这个任务。虽然我说得有点抽象，但我用一个例子来解释。假设你正在为客服创建一个聊天板，这时会收到来自客户的查询。这个查询可以是任何内容，可能是关于技术平台的，也可能是与退款相关的，或者是与销售相关的任何类型的查询。然后这个查询会到达我们的LLM，我们的LLM会决定这是否与退款相关。

这是一个查询还是技术相关的问题，或是销售相关的问题？如果是退款相关的问题，那么它会将您的请求路由到这个特定的LLM。如果是技术疑问，它会发送给第二个LLM；如果是销售相关的问题，它会发送给第三个LLM。所以基本上，这个LLM就像一个决策者一样工作，决定这三个LLM中哪一个最适合解决这个查询。所以从某种程度上说，这个特定的LLM调用就像一个路由器在工作。

好的，那么这也是一种模式，以后你会看到很多不同的工作流程。当你构建时，可能会用到这个小小的路由模式。所以，我希望到目前为止的两个LLM工作流程你已经理解了——提示链和路由。现在我们来谈谈下一个工作流程。下一个LLM工作流程叫做“并行化”，从名字上你可能已经猜到了。在这个特定的工作流程中，你会把一个给定的任务分解成多个子任务，然后同时执行所有这些子任务，最后合并它们的结果，得出最终的输出。明白了吗？

让我们举一个例子。假设你正在为像YouTube这样的平台创建一个内容审核工作流程。内容审核工作流程的意思是，每当有视频在YouTube上发布时，YouTube首先会检查该视频是否合适，是否可以公开播放，是否包含任何不当内容。那么，我们正在为YouTube构建同样的内容审核平台，明白吗？因此，对于内容审核，你需要从多个角度检查同一个视频。比如，你首先要检查该视频是否遵循了YouTube的社区准则。

第二个角度可能是你要检查视频中是否存在任何形式的错误信息，第三个角度可能是你要检查视频中是否包含任何色情内容。如果视频通过了这三个检查，我们才会将其上线，否则我们会将其标记为不合适。那么，我们在这里所做的是将内容审核任务划分为三个子任务：我们需要检查视频是否应该上线，而为了做出这个决定，我们需要检查这三个方面。有趣的是，这三个方面可以并行检查，并不是说为了检查错误信息，你必须事先知道视频的内容。

社区准则是否被遵守，或者是否存在色情内容，你需要事先知道是否存在错误信息。如果你已经完成了这三个任务，那么在这种情况下你会怎么做？如果你正在执行这些任务，你需要提取视频的内容，生成其转录本，并将其发送给第一个LLM。第一个LLM将检查该视频是否完全遵守了所有的社区准则。

第二个LLM将检查是否有缺失信息，第三个将检查是否存在性内容，然后这三个LLM各自将自己的结果发送给聚合器，聚合器将基于这三个结果决定视频是否应该发布。这是一个很好的并行化工作流程的例子，也是一个您会在许多地方看到的模式。我们也将在这个播放列表中处理它。我们的下一个LLM工作流程名为orchestrator worker workflow。老实说，这个特定的工作流程与并行化工作流程非常相似。

我们刚才读到的内容意思是，在这里你也需要将一个任务划分为多个并行的子任务，对吧？唯一的区别在于，在协调者-工作者模式中，你事先并不知道这些子任务的性质，这是动态决定的。就像在并行处理中发生的那样，在YouTube的例子中，你事先知道第一个LLM会根据社区准则来评判视频，第二个LLM会根据错误信息来评判。

第三个LLM将基于性内容来判断，这是预先定义的，但在协调器工作者中，事先并不知道第一个LLM会做什么工作，第二个会做什么工作，第三个会做什么工作。例如，你正在创建一个研究助手，其任务是针对给定的查询生成一份详细的研究报告。现在，在生成这份研究报告的过程中，我们的系统首先需要做的是在多个地方、多个平台上搜索该术语，然后将收集到的信息汇总并生成一份报告。

但是搜索在哪里进行以及搜索什么将取决于您的查询内容。例如，如果您的查询是某个科学术语或技术术语，那么您可能会告诉您的第一个LLM去Google Scholar搜索，在那里您可以找到研究论文，对吧？而如果您的搜索词是某种社会现象或政治事件，那么您可能会让您的LLM去Google新闻上搜索，对吧？

那么这里的情况是，根据输入的查询内容，搜索什么、在哪里搜索这些子任务会有很大的变化。因此，为了做出这些决策，这里有一个称为orchestrator的LLM。一旦搜索查询到来，orchestrator就会对其进行分析，并决定每个worker将获得什么任务。因此，根据输入查询的不同，orchestrator可以为每个worker LLM分配不同的任务。这就是这里最大的区别，所有事情都是并行进行的，最终将结果聚合起来。但一开始我们并不知道任务的性质会是什么，它会根据输入查询而变化。这也是一个非常重要的模式，非常重要的工作流程。

你将在未来看到的，希望我们也能在这个播放列表中涵盖它。最后一个常见的工作流程叫做评估优化器，这是一个非常有趣的工作流程。这里发生的情况是，你会被分配一个任务，而这个任务无法一次性完美执行。例如，你希望你的系统为你起草一封电子邮件，但很有可能第一次你不会得到完美的邮件。或者你想要你的系统为你撰写一篇关于某个主题的博客文章，同样也无法保证一次性就能完成。当你告诉你的LLM（大型语言模型）你需要一篇关于这个主题的博客文章时。

如果需要的话，它会把你的博客打磨到最佳状态。因为无论是撰写邮件草稿、创作博客、诗歌还是故事，这类工作都需要些许创造力，并且需要反复迭代。想想看——诗人或作家在创作时，往往采用迭代式写作：先完成初稿，再审视其中不足，将反馈融入第二稿，如此循环往复。经过5-6轮这样的流程，最终才能产出满意的作品。现在借助评估优化器工作流，你完全可以复制这套创作方法论。

在这里，你有两个LLM：一个是你的生成器LLM，另一个是你的评估器LLM。你从这里开始，说明你的任务，比如写博客或写邮件。然后，第一个LLM会为你生成一篇博客，我们称之为解决方案。现在，我们将这个解决方案发送给评估器，并告诉评估器一个具体的评估标准。基于这个标准，评估器会决定是接受还是拒绝你的解决方案。如果拒绝，它还会给出反馈。如果你被拒绝了并且收到了反馈，你的生成器会做什么呢？它会基于这个反馈再次生成新的解决方案。

它会一直处于自己的循环中，直到评估者满意为止，他认为这个解决方案是正确的，然后接受它，这个循环就会中断，你就会得到你的输出。这是一个非常有趣的工作流程，当我教你们关于循环的内容时，在语言图之后，我会向你们展示这个特定的工作流程，非常有趣。所以，我希望你们已经大致理解了LLM工作流程是什么，以及常见的五种不同工作流程，我已经全部告诉你们了。

在这个播放列表中，我将尝试涵盖所有这些核心概念。接下来我们要讨论的是图、节点和边的概念。相信我，朋友们，这三者结合起来可以说是LANGRAPH最重要的核心概念。如果你还记得视频开头我定义LANGRAPH是什么的时候，我告诉过你LANGRAPH是一个编排框架，它以图的形式表示任何LLM工作流程。这就是为什么你必须理解LANGRAPH如何以图的形式表示任何工作流程，任何LLM工作流程。为了完全解释这一点。

让我们举个例子，如果例子足够多，你可能已经知道在UPSC的Mains考试中，考生需要写一两篇论文，而这些论文实际上在Mains考试中占很大比重，被认为是通过UPSC考试的关键。因此，我们正在做的是建立一个网站，让所有UPSC考生可以练习写这些论文。具体来说，当用户访问我们的网站时，网站会为他们生成一个论文题目，然后用户可以开始写作。

在我们的网站上写一篇论文，他会输入并提交他的论文，我们的网站将从多个角度分析、评估这篇论文，并生成一个分数。如果分数超过分数线，我们会祝贺他；如果分数低于分数线，我们将提供反馈，然后给他选择的机会，如果他愿意，可以根据反馈重新写论文，然后我们会再次评估。整个过程基本上是我们以迭代的方式进行的，所以这是一个LLM工作流程。

你需要建立一个包含LLMs的流程，这样我们就可以在多个地方使用它。那么，我们如何利用land graph来构建这个LLM流程呢？首先，你需要将这个高层次的目标——即建立一个这样的网站——转化为可操作的步骤。这些可操作的步骤是什么呢？第一步是生成主题，第二步是收集学生写的文章，第三步是进行评估，第四步是从多个角度进行检查，然后将这些结果汇总。之后，告诉学生他们的文章是好还是不好，最后给出反馈。

之后，如果他愿意，可以再次修改并这样写。我们首先需要在纸上完整地写下这个流程。一旦你写好了，现在你可以借助实际流程图，将这个流程以图表的形式呈现出来，好吗？那么，我来展示给你看，我已经准备好了这个流程。所以这就是流程，就是我们刚才讨论的同一个流程，但这次是以图表的形式呈现的，好吗？所以你可以看到主题正在正确生成，首先是用户写文章，我们收集那篇文章，然后在这个步骤中我们对其进行评估。

我们基于三个方面进行评估：文章中思路的清晰度如何，分析的深度如何，是否进行了事实核查等。同时，我们还会检查文章的语言质量，词汇有多强，是否有语法错误，语气如何等等。基于这三个方面，我们给出一个标准化的评分，满分是15分。我们设定的及格线是10分。最终的评估结果是：如果你的分数超过10分，我们会祝贺你成功，流程就此结束；如果低于10分，我们会告知这篇文章未达到标准，并给予反馈。

我们将基于三个因素来判断错误所在，然后给他一个选择：是否愿意重写论文。如果他说“不”，流程就此结束；如果他说“是”，我们将回到这里，整个流程将重新执行。现在，你首先可以看到，任何这样的流程都可以非常容易地用图表的形式来表示——这是你应该注意到的第一点。其次，如果你观察这个图表，你会发现其中有两个主要元素：首先是节点（nodes）。

你会看到边缘 好的 现在有趣的是 这里的每个节点实际上代表了你工作流程中的一个单一任务 所以LangGraph所做的正是这样 当它构建图时 在构建图的过程中 每个节点代表一个单一任务 现在你可能会想 这个节点背后是什么 在LangGraph中 每个节点背后都是一个Python函数 仅此而已 除此之外没有别的 如果你了解Python函数，如果会写的话，你也可以创建这个节点，所以本质上如果你看语言图中所形成的图，它本质上是一组相互连接的Python函数，通过边来连接。边告诉我们，在某个特定节点执行后，下一个将执行哪个节点。简而言之，节点告诉我们做什么，边告诉我们什么时候做。

何时执行节点，你的边也可以有多种形式。你可能有顺序边，即一个接一个地执行；也可能有并行边，即同时执行多个任务；还可能有条件边，即进行分支选择，意味着流程可能朝这个方向或那个方向流动；或者你也可以实现循环。所以你可以看到，用这种图结构来表示整个工作流的好处在于，每个节点代表你的任务，边则代表它们之间的执行流程，而且你还能表达不同类型的流程，包括顺序流程。

可以表达分支，也可以表达循环，所有这些功能都能通过Lang Graph实现。因为Graph的结构为您提供了这种自由度。所以，我向您解释了Lang Graph如何轻松地将任何基于元素的优秀工作流转换为图形，以及该图形中的每个节点如何代表一个任务，而边则代表执行流程。显然，我所教给您的这一切都是非常实用的内容，只有当您实际编写代码时，才能真正体会到它的价值。但首先，我需要给您一个概念性的概述。我希望这一部分内容已经清晰明了。在下一个视频中，我们将创建我们的第一个工作流，届时您将亲眼看到您所学习的一切。

你现在可以多么轻松地在折线图中表达它，这是我们接下来要讨论的核心概念，名为“状态”。相信我，这是一个非常重要的核心概念。那么首先，让我们理解什么是“状态”。如果你谈论任何LLM工作流程，该工作流程在完成执行的过程中需要一些数据片段，这些数据在整个执行过程中提供帮助。例如，这是我们UPSC相关的LLM工作流程。这里有一些与该工作流程相关的数据点，在整个执行过程中是必需的。例如，你的候选人正在写的文章，这是一条信息或数据，你在整个执行过程中都会需要它。

想一想，当你需要进行评估时，你会基于什么来进行评估？就是这个essay文本。同样地，你在计算分数的地方，这里、这里，还有这里，这些也是信息的一部分，基于这些信息，后续的执行将取决于它们。因为，基于这些分数，你正在计算一个最终分数，然后基于这个最终分数，你将决定这个人的essay是好还是坏。

所以，我想说的是，当你创建任何NLM工作流程时，为了运行该工作流程并逻辑执行，你需要一些信息片段。这些信息的特点是它们会随着时间的推移不断演变，其中会不断发生变化。比如你看这里，假设用户正在写的文章被存储在某个变量中。但明天可能会出现这样的情况：他的文章没通过，写得不够好，于是他需要重新写一篇文章。那么我们就需要让他重新写，而新的文章我们会再次存储到同一个变量中。所以基本上，那个变量的内容会随着时间的推移不断演变。同样地，这里的分数也会随着你的工作流程的执行而不断变化。所以这个数据首先是与你的工作流程相关的，是执行所必需的；其次，它会随着时间的推移而演变，随着你的执行不断推进。这就是我们所说的状态。好了，这里已经写好了。

在Landgraft中，状态（state）是一个贯穿工作流的共享内存空间，它在图运行时保存着节点间传递的所有数据。因此，Landgraft中的状态是一个至关重要的组件——当你准备构建任何图时，Landgraft会要求你先定义状态，并在这个状态中以键值对的形式添加所有可能的数据点。比如在我们这个特定工作流中：文章文本可以是一个数据点，文章主题可以是另一个数据点，而语言深度评分也可以作为数据点存在。

她在清晰度方面得了多少分？她得了多少分？总分是多少？所有这些数据点都将帮助你执行，并随着时间的推移而发展。现在，与状态相关的最强大的事情是，在任何时刻，你的每个节点都可以访问这个状态。因此，当任何一个特定节点正在执行时，在执行时，首先在输入中会给出整个状态。然后这个节点执行其操作，并对这个状态进行更改，然后将这个状态传递给下一个节点。然后下一个节点收到相同的状态作为输入，在其中进行了更改，并将更改后的状态继续传递下去。所以实际上发生的事情是，这个状态首先是所有节点之间共享的，其次它是可变的。

所以所有这些节点都可以在其中进行更改，随着你的执行不断推进，这个状态也在不断演变，对吧？而这正是状态的最大特点。现在，你脑海中可能还有一个最后的问题：代码中是如何创建这个状态的？其实非常简单，它实际上是一个特殊的字典，我们称之为类型化字典。这基本上在Python中是一个类，所以你创建这个类的一个对象，并在对象中添加所有这些字段。如果你愿意，也可以创建一个Pydantic对象，但大多数情况下使用的是类型化字典。所以没什么特别的，它只是你代码中始终可用的一种字典，每个节点都有，对吧？

我再说一遍，这是一个非常重要的概念，你在以后写代码时会经常用到。所以请确保你已经完全理解了这一点。接下来我们要讨论的核心概念叫做 reducers，它与 state 的概念密切相关。如果你还记得的话，不久前我告诉过你关于 state 的两个重要事项：第一，你的 state 可以被你图中所有的节点访问，也就是说所有的节点都可以访问到 state 中的所有键值对。

第二个状态是可变的，这意味着任何节点都可以去改变你的状态。现在来看一个场景，这个场景是：我们正在设计一个非常基础的工作流程，其中我们输入两个数字，然后我们对这两个数字进行求和，接着将得到的结果乘以2，最后打印并显示结果。那么，在这个工作流程中，你会在你的状态中添加哪些键值对呢？

我想只要你稍微思考一下就会明白，这里有3个重要的数据点是你工作流程中需要的：第一个是第一个数字，第二个是第二个数字，第三个是结果。接下来会发生的是，一旦求和操作在结果中写入了一个值（比如11），下一个节点就会更新它，将其改为22，因为这个值是可变的。这就是多个节点可以对同一个值进行更新的情况。更新的意思就是删除旧值，放入新值。在大多数情况下...

移除旧的，放入新的值。现在在大多数情况下，整个流程都会正常运行，没有任何问题。但在某些特定场景中，这个更新状态的功能可能不会带来好处，反而会造成损害。例如，如果我们讨论另一个流程，假设我们正在构建一个简单的聊天机器人。现在来看聊天机器人的整个工作流程：会有一个人和一个LLM（大型语言模型），两者会在循环中相互交流。

好的，这就是我们的工作流程。现在如果问你，与这个工作流程相关的状态是什么，那么再次说明，它的状态非常简单。你只需在这里通过消息设置一个键值对。那么现在当执行开始时，你来到了人工节点，假设人工说“嗨，我叫尼提什”，那么这个节点会做什么呢？它会进入这个状态并更新为“嗨，我叫尼提什”。现在发生了什么？这个状态到达了LLM所在的节点，LLM节点看到这条消息后进行了回复。

嗨，有什么可以帮您的 嗨，有什么可以帮您的 好的，现在回到了这个节点的流程 现在这个节点有以下状态 然后用户又问了什么 can you tell me my name 所以基本上这个消失了，这个出现了 现在我们又回到了LLM节点 现在我有了这些信息 现在LLM看到这条消息后永远无法知道用户的名字是什么 因为包含用户名字的那条消息已经从状态中擦除了 所以在这种情况下

你更新状态的这个策略实际上在类似聊天机器人的场景中是失败的。理想情况下，你应该怎么做呢？与其更新消息，不如将迄今为止在聊天中收到的所有消息逐一添加进去。这就是reducer的基本概念。reducer告诉你，状态中的更新将如何进行——是替换、添加还是合并？这就是reducer的作用。看这里，写着“reducer in language defines”。

节点更新如何应用到共享状态中，状态的每个键都可以有自己的reducer。也就是说，一个键可能允许更新，另一个键可能不允许添加，第三个键可能允许合并，每个键都可以有自己的reducer。状态的每个键都可以有自己的reducer，它决定了新数据是替换、合并还是添加到现有值上。好的，就像我们的这个UPSC用例一样，在这里我也会给你展示一个例子，你需要保留雷达更新时的状态值。

例如，我们有一个键值对，用这样的文字表达没问题。我们在这里存储学生写的任何内容。现在的情况是，第一次写的内容不太好，用户说：“兄弟，我要重新写一个新的。”于是他会来这里写新的内容，就像他会写新的那样，这个变量的值会改变，而他之前写的内容将会丢失，会消失，对吧？

然后他又下来了，再次评估后发现，不行，反馈还是不好，于是他又重新来过，第三次这样写，现在第二个也会这样消失，第三个会在这里存储。但如果那个学生想看，他想看自己的第一个版本，也想看第二个版本，还想看第三个版本，他想看看自己是如何改进的。在这种情况下，更新的政策并不好。在这种情况下，你可以添加，你可以保留第一个版本，放在它的前面。

second 要这样添加，然后 third 要这样添加，那么你只需要在这里说 add，然后必须提供一个函数。这样做的效果是，之前的不会被擦除，新的会不断添加。好的，所以 reducer 的基本概念就是这样。reducer 告诉我们 state 的更新将以何种方式进行——是替换、添加还是合并。reducer 就是用来定义这种方式的。好的，以后我会在某个用例中向你们展示 reducers。一般来说，当你创建并行工作流时，reducers 会更加有用。所以希望当我们创建并行化的工作流时，在那里会用到它。

我可以向你展示如何编写和使用reducers。在结束这个视频之前，我想和大家讨论最后一件事，这件事有点概念性，那就是Langrath的执行模型。所以我想稍微和大家讨论一下，Langrath在幕后是如何执行一个工作流的。在解释整个事情之前，我想告诉你一个有趣的事实：Langrath所依赖的这个完整的执行模型实际上是受Google Pregel启发的。Google Pregel是什么？

这基本上是一个系统，可以在非常大的规模上进行图形处理，并且这个东西已经集成到谷歌的许多产品中。所以Langrath创建了自己的执行模型，它很大程度上受到了谷歌Pregel的启发。那么我来告诉你，当你在Langrath中创建并运行一个工作流时，幕后发生了什么。首先，你会做什么呢？比如你被要求创建一个工作流，你首先要做的是创建一个与该工作流相关的图形。创建图形意味着你在做三件事：第一，你定义了它的节点和边。

你在做的是创建一个状态，这整个过程被称为图形定义。一旦你定义好了你的图形，接下来你会做什么？你会编译它。编译的主要目的是检查你所创建的图形结构在逻辑上是否正确。比如说，有没有一个节点没有连接到其他任何节点，我们称之为孤立节点。这种不一致性不应该出现在你的图形结构中。所有这些都是在编译步骤中检查的。实际上，这里有一个叫做编译的函数，你调用它。一旦编译完成，你的执行阶段就开始了。在这里，你首先做的是调用。

那么调用中你的工作就是，将你的初始状态传递给图表中的第一个节点。一旦你传递了初始状态，这个特定的节点就会被激活。激活意味着与该节点关联的Python函数会被调用，并开始执行其任务。完成任务后，它会对你的状态进行部分更新。当状态发生部分更新时，更新后的状态会自动通过这条边传递到下一个节点。然后你的下一个节点会以完全相同的方式被激活，明白吗？接着它也会执行自己的任务，对状态进行部分更改，然后再次通过节点边传递状态。

如果它向前发送，那么我们不断使用边缘将状态发送到下一个节点，这个过程被称为消息传递，明白吗？而这一轮一轮的工作，比如这是一轮，然后同样这是第二轮，然后同样这是第三轮，那么这一轮一轮的工作在语言图的术语中被称为超级步骤。为什么不叫步骤而叫超级步骤呢？这非常有趣，我也会告诉你。比如你在这个特定阶段可以看到，这里的负载已经激活了。你的这个特定右侧节点被触发并激活了，它的功能被调用了，并在状态内部进行了一些更新。现在通过消息传递，这个更新后的状态会继续传递到下一个节点。注意这里接下来有三个并行节点，所以你的系统需要将这个信息发送到所有三个节点，然后这三个节点会同时开始工作，并在状态上同时进行更新。所以这就是你现在的步骤。

这包括三个并行步骤，这就是为什么兰格拉特认为与其称之为步骤，不如称之为超级步骤。因为图的结构有时会出现并行调用，即多个步骤同时执行，所以称它们为步骤在逻辑上并不合理，因此我们称之为超级步骤。然后，这三个步骤会进行状态更新，经过reducer的合并处理，再通过这些边的传递到达下一个节点。类似地，下一个节点被激活，执行其任务，更新状态，并进行消息传递。如此反复进行。

当你到达终点时，一切都很好，你的整个执行过程会在以下情况下停止：当你没有任何活动节点，并且你的边缘没有传递任何消息时。如果这两个条件都成立，那么你的工作流程就会停止。这里唯一需要解释的是，当你用多个节点创建这个图时，你不需要手动调用一个节点然后再调用另一个节点。你不会这样做。你会先调用第一个节点，给它状态，等它的工作完成后，再调用第二个节点并发送状态。不，所有这些工作都是内部自动完成的。在这整个过程中，你会听到两三个接下来会提到的内容，那就是下一个节点通过边缘传递的状态。

发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 发送到下一个节点 那些重要的概念 核心概念 你会反复听到的 我们在这里讨论 理论上，概念上 现在向前迈进 我觉得当你在代码中做这些事情时 你不会觉得这些东西是新的和外来的 你会觉得是的 这个我读过 这就是为什么我单独拍摄了这个视频 我真的希望这有帮助 如果你喜欢这个视频 请点赞 如果你还没有订阅频道 请订阅 我们下个视频见 再见
