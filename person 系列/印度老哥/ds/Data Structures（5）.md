
## 21、使用栈的中缀转后缀

在上节课中，我们学习了如何计算前缀和后缀表达式。这节课，我们将学习一种将中缀表达式转换为后缀表达式的高效算法。我们已经知道一种手动转换的方法，即运用运算符优先级和结合性规则来进行转换。现在，让我们来转换我在这里写的这个表达式。乘法运算符的优先级更高，因此我们会先转换这部分 B 星号 C。B 星号 C 会变成 BC 星号，运算符会出现在操作数前面。

现在我们可以对这个加法进行转换。对于加法，操作数是A和这个后缀表达式。在最后一步，我们可以去掉所有的括号。所以最终这就是我的后缀表达式。我们也可以在程序中使用这个逻辑，但它不会非常高效，实现也会有些复杂。我要讲一个真正简单高效的算法，在这个算法中，我们只需要从左到右解析一次中缀表达式，就可以创建出后缀表达式。

在中缀表达式转后缀表达式的过程中，操作数的位置和运算符的位置可能会发生变化，但操作数从左到右的顺序不会改变。运算符的顺序可能会发生变化。这是一个重要的观察结果。在这里的中缀和后缀形式中，操作数从左到右的顺序都是先有A，然后有B，最后有C，但运算符的顺序是不同的。在中缀表达式中，首先是加号，然后是乘号。

在后缀表达式中，乘法优先于加法。后缀表达式的运算符顺序始终与其执行顺序一致。我将再次演示这种转换，但这次会采用不同的逻辑方法。具体操作是从左到右解析中缀表达式，逐个检查每个标记——这些标记可能是操作数或运算符。以这个表达式为例，我们从A开始。A是操作数。遇到操作数时，可以直接将其附加到我们正在构建的后缀字符串或表达式中。

至少对于A来说，这一点应该非常明确：在A之前不可能出现任何内容。好的，那么第一条规则是，如果遇到操作数，我们可以直接将其放入后缀表达式中。接下来我们遇到一个运算符。由于尚未看到其右操作数，我们不能直接将运算符放入后缀表达式。在解析过程中，我们目前只看到了它的左操作数。只有在其右操作数也被放置后，我们才能放置这个运算符。

因此，我将把这个运算符单独保存在一个列表或集合中，稍后在可以放置时再将其放入后缀表达式中。而我将用于存储的结构是栈。栈只是一种特殊的列表，其中后进先出。插入和删除操作都发生在同一端。这里我已经将加号运算符压入栈中。接下来是操作数B。正如我们所说，操作数可以直接追加。在这个操作数之前不能有任何东西。栈中的运算符实际上是在等待操作数的到来。那么在这个阶段，我们是否可以将加法运算符放入后缀字符串中呢？实际上，B之后的内容也很重要。

在这种情况下，B后面跟着这个乘法运算符，它的优先级更高，所以加法的实际操作数是整个表达式B乘以C。在乘法完成之前，我们无法执行加法。因此，在解析时，当我处于B的位置，还没有看到B后面的内容时，我无法决定栈中运算符的命运。所以让我们继续前进。现在我们有了这个乘法运算符。为了让解释更清楚，我想让这个表达式变得更复杂一些。

所以我现在在这个表达式的末尾添加了一些内容。现在我想把这个表达式转换成后缀形式。我这里没有任何括号。我们稍后会看到如何处理括号。让我们来看一个括号不覆盖运算符优先级的表达式。好的，现在在这个表达式中，从左到右解析时，我们处于这个乘法运算符的位置。乘法运算符本身不能进入后缀表达式，因为我们还没有看到它的右操作数，直到它的右操作数被放置在后缀表达式中，我们才能放置它。

在解析过程中，我们正在查看的运算符本身并不能立即放置。但通过观察该运算符，我们可以决定是否将集合或堆栈中的某些内容放入我们正在构建的后缀表达式中。堆栈中优先级高于当前查看运算符的任何运算符都可以被弹出并放入后缀表达式。我们暂且按这个规则执行，稍后我会解释原因。当前栈中只有一个运算符，且其优先级不高于乘法运算符。因此我们不会将其弹出并放入后缀表达式中。乘法运算符本身会被压入栈中。如果栈中某个元素上方还有其他元素，那么上方的元素必定具有更高的优先级。现在让我们继续解析这个表达式。

现在我们到了C，它是一个操作数，所以可以直接输出。接下来我们遇到一个减法运算符。减法运算符本身不能直接输出。但正如我们之前所说，如果栈中有比当前运算符优先级更高的运算符，就应该将其弹出并输出。那么问题来了，为什么？我们将这些运算符压入栈中，而不是直接放入后缀表达式，因为我们不确定是否已经处理完右操作数。

但在那之后，一旦遇到优先级更低的运算符，就标志着右操作数的边界。对于这个乘法运算符来说，C就是我的右操作数，它只是一个简单的变量。而对于加法运算符来说，B乘以C就是我的右操作数。因为减法的优先级更低，所以在那之后或之后的内容都不能成为我的右操作数。准确地说，由于结合性规则，减法的优先级更低。

如果你记得运算顺序的话，加法和减法具有相同的优先级，但出现在左边的运算符会被优先处理。所以思路是，任何时候遇到一个运算符时，如果我得到一个优先级较低的运算符，就可以从栈中弹出它并放入表达式中。这里我们会先弹出乘法并放置，然后可以弹出加法，现在我们将减法压入栈中。

现在继续。D是一个操作数，所以直接输出。接下来遇到乘法运算符。栈中没有比乘法优先级更高的运算符，因此不弹出任何内容。乘法运算符将压入栈中。接着遇到一个操作数，直接输出。现在有两种方式可以确定运算符右操作数的结束位置：A是遇到优先级更低的运算符；B是到达表达式末尾。

既然我们已经到达表达式的末尾，我们可以简单地弹出并放置这些运算符。所以首先是乘法运算符，然后是减法运算符。让我们快速写下到目前为止我所说的伪代码，然后你可以通过一些例子坐下来分析逻辑。我将编写一个名为 infix to postfix 的函数，它将接受一个字符串 exp（表达式）作为参数。

为了简单起见，我们假设每个操作数或运算符仅由一个字符组成。在实际实现中，你可以假设它们是由多个字符组成的标记。因此，在我的伪代码中，我要做的第一件事是创建一个名为S的字符栈。现在，我将运行一个从0开始到表达式长度减1的循环。这样我就能逐个查看每个字符，它可能是操作数或运算符。

如果字符是操作数，我们可以将其附加到后缀字符串中。实际上，我应该在循环之前声明并初始化一个字符串。这是我将要附加的结果字符串。否则，如果表达式I是运算符，我们需要在堆栈中寻找具有更高优先级的运算符。所以我会说，当堆栈不为空且堆栈顶部具有更高优先级时，假设这个函数hasHigherPrecedence将接受两个参数，即两个运算符。

因此，如果栈顶运算符的优先级高于当前扫描的运算符，我们就可以将栈顶运算符追加到结果变量（即存储后缀表达式的字符串）中，然后弹出该运算符。这里假设S是某个实现了stop、pop和empty方法（用于检查栈是否为空）的类。最后，在while循环外部完成弹出操作后，需要将当前运算符压入栈中。S是某个类的对象，它将具有这些函数：Stop、pop和empty。好的，这是我的for循环的结尾。在循环结束时，我可能在栈中还有一些运算符。我将弹出这些运算符并将它们附加到后缀字符串中。我会使用这个while循环。

我会说，当栈不为空时，将顶部的操作符追加并弹出，最后在这个while循环之后，我可以返回结果字符串，其中将包含我的后缀表达式。这就是我目前为止解释的逻辑的伪代码。在我的逻辑中，我没有处理括号。如果我的中缀表达式带有这样的括号怎么办？与我们之前所做的会有些许变化。有了括号后，表达式中的任何括号内的部分都应被视为独立的完整表达式，括号外的任何元素都不会影响其执行。在这个表达式中，这部分A加B位于一个括号内。它的执行不会受到括号外的这个乘法或减法的影响。

同样地，整个这部分都在外层的括号内。因此，外面的乘法运算符不会对这一部分的整体执行产生任何影响。如果括号是嵌套的，内层括号会先被处理或解析，然后才能解析外层括号。对于括号，我们会有一些额外的规则。我们仍然会从左到右进行，仍然会使用堆栈，假设我会在这里写下我创建的后缀部分。

在解析过程中，一个标记可以是一个操作数、一个运算符，或者是一个开括号或闭括号。我们会有一些额外的规则。我会先说明这些规则，然后再进行解释。如果遇到开括号，我们可以将其压入堆栈。在这个例子中，第一个标记是一个开括号，所以它会被压入堆栈，然后我们继续。我们又遇到了一个开括号，所以再次将其压入堆栈。现在我们有一个操作数。对于操作数，规则没有变化。

它将被简单地附加到后缀部分。接下来我们有一个运算符。还记得我们之前对运算符的处理方式吗？我们会查看栈顶，只要遇到更高优先级的运算符就持续弹出。之前在不使用括号的情况下，我们可以一直弹出直到清空栈，但现在我们需要查看栈顶，并且只在遇到开括号时才停止弹出，因为如果我们遇到开括号，那就意味着这是最后一个开括号的边界，此运算符在此之后就不再有任何影响了。

所以这个加号运算符在左括号之外没有任何影响。稍后我会用更多例子来解释这个场景。首先我们来理解规则。规则是，如果我看到一个运算符，我需要查看栈顶。如果它是一个优先级更高的运算符，我可以弹出它，然后我应该查看下一个栈顶元素。如果再次遇到优先级更高的运算符，我应该再次弹出，但当我看到一个左括号时就应该停止。

现阶段，顶部有一个左括号，因此我们无需查看其下方内容。无论如何都不会有元素弹出。但加法运算符会被压入堆栈。记住，在完成所有弹出操作后，我们还要将运算符本身压入堆栈。接下来遇到一个操作数，它会直接进入堆栈，然后我们继续处理。随后遇到一个右括号。当我遇到右括号时，就意味着最近打开的括号在逻辑上到达了终点。

对于括号内的这部分表达式，它即将结束，还记得我们之前处理中缀表达式结束时所做的操作吗？我们当时将所有运算符弹出并放置。因此，这次我们也需要弹出所有运算符，但仅限于属于我们正在关闭的这个括号内的那些运算符。因此，我们需要弹出所有运算符，直到遇到一个开括号。我现在弹出这个加号并附加它。接下来我们遇到一个开括号，所以我会停止，但作为最后一步，我也会弹出这个开括号，因为这对括号的处理已经完成。好的，所以对于闭括号的规则是：一直弹出运算符，直到遇到一个开括号，最后也要弹出那个特定的开括号。现在让我们继续。接下来我们有一个运算符。

我们需要查看栈顶元素。这是一个左括号。这个运算符会被直接压入栈中。接下来我们遇到一个操作数。然后是一个运算符。我们再次查看栈顶元素。发现乘法运算符的优先级更高。因此应该将其弹出并附加到结果中。我们会再次查看栈顶元素。这是一个左括号的开始，所以我们现在应该停止查找。减号现在会被压入。接下来我们有一个操作数。然后我们有一个右括号的结束。所以我们需要弹出直到遇到一个左括号。减号会被附加。

最后，开括号也会被弹出。接下来我们有一个运算符，它会简单地被处理。然后我们有一个操作数，现在我们已经到达表达式的末尾。因此，堆栈中的所有内容都将被弹出并附加。所以最终这就是我的后缀表达式。我会再举一个例子并进行转换，以使事情更加清楚。我想转换这个表达式。我会从头开始。首先我们有一个操作数。

然后这个乘法运算符将简单地进入堆栈。现在堆栈是空的。顶部没有任何内容需要转换。我们将继续，接下来有一个操作数，它会被追加，现在我们转到这个加法运算符。如果这个开括号不在那里，堆栈的顶部将是乘法运算符，它的优先级更高，所以它会被弹出，但现在我们看顶部，它是一个开括号，所以我们不能往下看，只能继续。接下来我们有C，我上次忘了把加法运算符压入堆栈。

好的，在C之后，我们遇到了这个闭括号，所以需要不断弹出栈顶元素直到遇到对应的开括号，然后还需要再弹出一个开括号。最后，我们已经到达表达式的末尾，因此栈中的所有元素都会被弹出并附加到结果中。这样最终就得到了我的后缀部分，也就是后缀表达式形式。在我之前写的伪代码中，只有这个for循环内的部分需要修改以处理括号的情况。如果我们遇到一个运算符，需要查看栈顶元素并弹出，但只在我们遇到开括号之前才这样做，所以我在while循环中额外添加了这个条件。

这个条件将确保我们在遇到左括号时停止。目前，在for循环中，我们正在处理操作数和运算符。我们还将有两个条件。如果是左括号，我们应该压入栈；如果是右括号，我们可以继续弹出并追加。假设这个函数是左括号，我们将检查一个字符是否是左括号。

事实上，在这里检查当前标记是否为开头时，我们也应该使用这个函数，因为它可能是开大括号或开括号。这个函数会负责处理。可以说这个函数会搞定。同样地，对于最后一个else if，我们应该使用这个函数来判断是否为闭括号。好了，现在逻辑一致了。在这个while循环之后的最后一个else if里，我们应该额外执行一次pop操作，这次额外的pop会弹出开括号。现在我们完成了这个else if，这也是我的for循环的结束部分。其余部分保持不变。

在for循环之后，我们可以弹出剩余部分并附加到字符串中，最后返回结果。这就是我最终的伪代码。你可以查看本视频描述中的链接，获取实际实现的源代码。好的，我就讲到这里。本节课的内容就这些。感谢观看。

## 22、队列

大家好。我们已经讨论了一段时间的数据结构。众所周知，数据结构是计算机中存储和组织数据的方式。在本系列中，我们已经讨论了数组、链表等数据结构，并在最近几节课中讲解了栈的概念。本节课我们将向大家介绍队列。我们会像讲解栈时那样，先讨论队列的抽象数据类型（ADT）。我们知道，当我们将某个数据结构视为抽象数据类型时，只定义该数据结构可用的功能或操作，而不涉及具体实现细节。

我们将在后续课程中探讨具体的实现方法。本节课我们仅讨论队列数据结构的逻辑概念。好的，现在开始讲解。队列数据结构正如其名，与我们日常生活中排队的含义完全一致。队列是一种先进先出的结构，简称为 FIFO 结构。之前我们学习过栈结构，它是一种后进先出的结构，简称 LIFO。栈是一种集合数据结构，其插入和删除操作都发生在同一端，我们称之为栈顶。而队列则不同，插入操作必须发生在称为队尾的一端，删除操作则必须发生在另一端，我们称之为队头。

如果要从形式上把队列定义为一个抽象数据类型，那么队列就是一种具有限制条件的列表或集合：插入操作只能且必须在称为队尾的一端进行，而删除操作则只能在称为队头或队首的另一端执行。现在我们来定义队列支持的接口或操作。与栈类似，队列也有两个基本操作：插入操作称为入队（enqueue），也有人喜欢称之为压入（push）。入队操作应在队列的尾部插入一个元素。

删除操作被称为出队操作。在某些实现中，人们也把这个操作称为弹出。在栈的上下文中，压入和弹出更为人熟知。而在队列的上下文中，入队和出队更为常见。在实现时，你可以在接口中选择使用这些名称中的任何一个。出队操作应该从队列的前端或头部移除一个元素，并且通常还会返回这个从头部移除的元素。对于一个整数队列来说，入队和出队的函数签名可以像这样。

这里的入队操作返回void，而出队操作返回一个整数。这个整数应该是从队列中移除的元素。你也可以将出队操作设计为返回void。通常我们会保留第三个操作front或peak，仅用于查看队列头部的元素，就像我们在栈中保留的top操作一样。这个操作应该只返回前端的元素，而不删除任何内容。好的，我们还可以增加一些操作。我们可以有一个操作来检查队列是否为空。如果队列的大小有限制，那么我们还可以有一个操作来检查队列是否已满。

我之所以要指出这些操作的不同名称，也是因为大多数时候我们并不需要自己实现数据结构。我们使用语言库中内置的实现。不同语言库的接口可能有所不同。例如，如果你使用C++内置的队列，插入的函数是push，而在C#中则是enqueue。所以我们不应该混淆。我就把更知名的名字放在这里。好的，这些是我为队列ADT定义的操作：入队（enqueue）、出队（dequeue）、查看队首（front）和判空（isEmpty）。我们可以通过入队和出队操作每次在队列中插入或移除一个元素，查看队首仅用于观察头部元素，判空则用于验证队列是否为空。我在这里写的所有这些操作都必须以恒定时间完成，换句话说，它们的时间复杂度应该是O(1)。从逻辑上讲，队列可以表示为一个两端开放的图形或容器。

因此，元素可以从一端插入（入队），而从另一端移除（出队）。如果你还记得栈的话，我们曾将栈描述为一个仅一端开放的容器。在栈的语境中，插入（我们称之为压入）和移除（弹出）都必须发生在同一端；而在队列中，插入和移除应当发生在不同的两端。假设我想创建一个整数队列。初始时我们有一个空队列，我会先写下其中一个操作，然后在逻辑视图中向你展示模拟过程。假设我首先想将数字2入队。

我现在展示的这个图是一个空的整数队列。我正在这里执行一个入队操作。在程序中，我会调用一个入队函数，并将数字2作为参数传递给它。这次入队后，队列中就有了一个元素，即一个整数。因为目前队列中只有一个元素，所以队列的前端和后端是相同的。让我们再入队一个整数。现在我想插入数字5，5将被插入到队列的后端或尾部。让我们再入队一个。现在我想调用出队操作。

因此我们将从队列头部取出两个元素并将其移除。如果出队操作需要返回这个被移除的整数，那么我们将得到整数二作为返回值。入队和出队是队列的基本操作。在我们的设计中，为了方便起见还可以添加更多功能。比如这里我们提供了获取队首元素和判空功能——在当前阶段调用获取队首元素会返回数字五（整数五），但不会从队列中移除任何元素。此时调用判空函数会返回布尔值false，或者用0表示false，1表示true。以上就是队列的基本运作原理。

现在一个显而易见的问题是，在哪些实际场景中我们可以使用队列？队列数据结构有哪些应用案例？队列最常用于存在共享资源需要处理某些请求的场景中。但该资源一次只能处理一个请求，同一时间只能服务一个请求。在这种情况下，最合理的做法是将请求排队，先到的请求先得到服务。假设我们有一个网络共享的打印机，网络中的任何机器都可以向这台打印机发送打印请求。打印机一次只能处理一个请求，同一时间只能打印一份文件。因此，如果它在忙碌时收到请求，它不能直接说“我很忙，稍后再请求”，那样对打印机来说就太粗鲁了。实际上发生的是，管理打印机的程序会将打印请求放入一个队列中。

只要队列中有内容，打印机就会不断从队列前端取出请求并处理。你电脑上的处理器也是一种共享资源。许多正在运行的程序或进程都需要处理器的时间，但处理器一次只能处理一个进程。处理器就是那个必须执行所有指令、完成所有算术和逻辑运算的家伙。因此，这些进程会被放入队列中。队列通常可用于模拟多种场景中的权重。在后续课程中解决一些问题时，我们将详细讨论队列的这些应用。作为入门介绍，这部分内容已经足够。下节课我们将学习如何实现队列。本节课的内容就到这里。感谢观看。

在上节课中，我们向大家介绍了队列数据结构。我们讨论了队列作为一种抽象数据类型（ADT）。



As we know, when we talk about a data structure as abstract data type, we define it as a mathematical or logical model. We define only the features or operations available with the data structure and do not go into implementation details. In this lesson, we are going to discuss possible implementations of queue.I will do a quick recap of what we have discussed so far. A queue is a list or collection with this restriction with this constraint that insertion can be performed at one end that we call rear of queue or tail of queue and deletion can be performed at other end that we call the front of queue or the head of queue and insertion in queue is called in queue operation or deletion is called dequeue operation. I have defined queue ADT with these four operations that I have written here.In an actual implementation, all these operations will be functions. Front operation should simply return the element at front of queue, it should not remove any element from the queue is empty should simply check whether queue is empty or not. And all these operations must take constant time and queue dequeue or looking at the element at front, the time taken for any of these operations must not depend upon a variable like number of elements in queue, or in other words, time complexity of all these operations must be big O of one.Okay, so let's get started. We are saying that a queue is a special kind of list in which elements can be inserted or removed one at a time and insertion and removal happen at different ends of the queue. We can insert an element at one end and we can remove an element from the other end just the way we did it for stack.We can add these constraints or extra properties of queue to some implementation of a list and create a queue. There are two popular implementations of queue, we can have an array based implementation, and we can have linked list based implementation. Let's first discuss array based implementation.Let's say we want to create a queue of integers. What we can do is we can first create an array of integers. I have created an array of 10 integers here I have named this array A. Now what I'm going to do is I'm going to use this array to store my queue.What I'm going to say is that at any point, some part of the array starting an index marked as front till an index marked as rear will be my queue. In this array, I'm showing front of the queue towards left and rear towards right. In earlier examples, I was showing front towards right and rear towards left doesn't really matter.Any side can be front and any side can be rear. It's just that an element must always be added from rear side and must always be removed from front. So if at any stage, a segment of the array from an index marked as front till an index marked as rear is my queue and rest of the positions in the array are free space that can be used to expand the queue.To insert an element to end queue, we can increment rear. So we will add a new cell in the queue towards rear end and in this cell, we can write the new value. Element to be inserted can come to this position.I'll fill in some values here at these positions. So we have these integers in the queue and let's say we want to insert number 5. To insert, we will increment rear. Of course, there should be an available cell in the right and available empty cell in the right and now we can write value 5 here.After insertion, new rear index is 7 and the value at index 7 is 5. Now dequeue means we must remove an element from front of the queue. In this example here, a dequeue operation should remove number 2 from the queue. To dequeue, we can simply increment front because at any point, only the cells starting front till rear are part of my queue.By incrementing front, I have discarded index 2 from the queue and we do not care what valuelies in a cell that is not part of the queue. When we will include a cell in the queue, we will overwrite the value in that cell anyway. So just incrementing front is good enough for dequeue operation.Let's quickly write pseudocode for whatever we have discussed so far. In my code, I will have two variables named front and rear and initially I'll set them both as minus 1. Let's say for an empty queue, both front and rear will be minus 1. To check whether queue is empty or not, we can simply check the value of front and rear and if they are both minus 1, we can say that queue is empty. I just wrote is empty function here.Minus 1 is not a valid index. For an empty queue, there will be no front and rear. In our implementation, we are saying that we will represent empty state of queue by setting both front and rear as minus 1. Now let's write the enqueue function.Enqueue will take an integer x as argument. There will be couple of conditions in enqueue. If rear is already equal to maximum index available in array A, we cannot insert or enqueue an element.In such scenario, we can return and exit. I would rather use a function named isFull to determine whether queue is full or not. If queue is already full, we can't do much.We should simply exit. Else if queue is empty, we can add a cell to the queue, we can add cell at index 0 in the queue and now we can set the value at index rear as x. In all other cases, we can first increment rear and then we can fill in value x at index rear. I can get this statement a rear equal x outside these two conditional statements because it's common to them.So this is my enqueue function. In the example array that I'm showing here, let's enqueue some integers. I'll make calls to enqueue function and show you the simulation in the figure here.Let's say first I want to insert number 2 in the queue. I'm making a call to enqueue function passing number 2 as argument. The queue is empty so we will set both front and rear as 0. Now we will come to this statement.We will write value 2 at index 0. So this is my queue after one enqueue operation. Front and rear of the queue is same. Let's make another call to enqueue.This time I want to insert number 5. This time queue is not empty so rear will be incremented.We have added a cell to the queue by incrementing rear and now we will write the value 5 at thenew rear index. Let's enqueue one more number.I have enqueued 7. Let's now write dequeue operation. There will be couple of cases in dequeue.If the queue is already empty, we cannot remove an element.

In this case we can simply print or throw an error and return or exit. There will be one more special case. If the queue has only one element, in this case front and rear will not be minus 1 but they will both be equal because we are already checking for minus 1 case in is empty function in the previous if.In this else if, we can simply check whether front is equal to rear or not. If this is the case, a dequeue will make the queue empty and to mark the queue as empty, we need to set both front and rear as minus 1. This is what we had said that we will represent an empty queue by marking both front and rear as minus 1. In default or normal scenario, we will simply increment front. We should really be careful about corner cases in any implementation.That's where most of the bugs come. Ok, so this finally is my dequeue function. In this example here, at this stage, let's say we want to perform a dequeue.Queue is not empty and we do not have only one element in the queue. So we will simply increment front. Before incrementing, we could set the value in this cell at index 0 as something but the value in a cell that is not part of queue anymore doesn't really matter.At this stage, it doesn't really matter what we have at index 0 or index 3 or any other index apart from the segment between front and rear. When we will add a cell in the queue, we will overwrite the value in that cell anyway. Let's now perform some more enqueues and dequeues.I am enqueuing 3 and then I am enqueuing 1. With each enqueue, we are incrementing rear. I just performed some more enqueue here. Now let's perform a dequeue.If I will perform one more enqueue here, rear will be equal to maximum index available in the array. Let's enqueue one more. Now at this stage, we cannot enqueue an element anymore because we cannot increment rear.Enqueue operation will fail now. There are two unused cells right now but with whatever logic we have written, we cannot use these two cells that are in the left of front. In fact, this is a real problem as we will dequeue more and more.All the cells left of front index will never be used again. They will simply be wasted. Can we do something to use these cells? Well, we can use the concept of a circular array.Circular array is an idea that we use in a lot of scenarios. The idea is very simple. As we traverse an array, we can imagine that there is no end in the array.From 0, we can go to 1. From 1, we can go to 2. And finally, when we will reach the last index in the array, like in this example, when we are at index 9, the next index for me is index 0. We can imagine this array something like this. Remember, this is only a logical way of looking at the array. In circular interpretation of array, if I'm pointing to a position and my current position is i, then the next position or next index will not simply be i plus 1. It will be i plus 1 modulo the number of elements in array or the size of array.Let's say n is the number of elements in array. Then the next position will be i plus 1 modulo n.The modulo operation will get us the remainder upon dividing by n. For any i other than n minus 1, this modulo operation will not have any effect. But for i equal n minus 1, next position will be n modulo n which will be equal to 0. When you divide the number by itself, the remainder is 0.Previous position in circular interpretation of array will be i plus n minus 1 modulo n. We could simply say i minus 1 modulo n just to make sure this expression inside the parenthesis is always positive.I'm adding n here. Give this some thought, you should be able to get why it should be i plus n minus 1 modulo n. Now with this interpretation of array, we can increment rear in an enqueue operation as long as there is any unused cell in the array. I'm going to modify functions in my pseudocode now.Is empty will remain the same. We are still saying that for an empty queue, front and rear will be minus 1. Let's scroll down and come to enqueue. Now in circular interpretation, I will call my queue full when the position next to rear in circular interpretation that we will calculate as rear plus 1 modulo n will be equal to front.So we will have a situation like this. Right now, the next position to rear in circular interpretation is front. So there is no unused cell, the complete array is exhausted, nothing will change in this condition.If q is empty, we can simply set front and rear as zero. In the last else condition, we will increment rear like this, we will say rear is equal to rear plus 1 modulo n, where n is number of elements in the array. With this much change, my enqueue function is good.Now let's make a call to enqueue and insert something in this array here. I want to insert number 15. We will come to this last else condition.rear right now is 9. So this expression will be 9 plus 1 modulo n, n is 10 here, the size of this array a is 10 here, this will evaluate to zero. Now my new rear is zero, I will write number 15 here. Let's now see what we need to do in the queue function.Nothing will change in the first two conditions. If q is already empty, or if there is only one element in the queue, we will handle these cases in same manner. In the final else, when we are incrementing front, we need to increment it in a circular manner.So we will say front equal front plus 1 modulo n, where n is number of elements in the array, total number of elements in the array or size of array. Now let's perform a dequeue, we will come to this condition front right now is 2. So this will be 2 plus 1 modulo 10. One more cell is available to us now.This much is the core of our implementation. Front operation will be really straightforward, we simply need to return the element at front index. Here also we first need to check whether q is empty or not, we should return a front only when front is not equal to minus 1. All these operations, all these functions that I have written here will take constant time, their time complexity will be big O of 1. We are performing simple arithmetic and assignments in the functions and not doing anything costly like running a loop.So time taken will not depend upon size of q or some other variable. I'll leave this here. It should not be very difficult converting this pseudo code to a running program in a language of your choice.If you want to see my code, you can check the description of this video for a link. Thanks for watching. In our previous lesson we saw how we can implement q using arrays.Now in this lesson we will see how we can implement q using linked list. Q as we know from our previous discussions is a structure in which whatever goes in first comes out first. Q data structure is a list or collection with this restriction that insertion can be performed at one end and deletion can be performed at other end.These are typical operations that we define with q and insertion is called in q operation and deletion is called dq. Front operation, front function should simply return the element at front of list and is empty should check whether q is empty or not. And all these operations must take constant time, their time complexity should be big O of 1. When we were implementing q with arrays, we used the idea of a circular array to implement q. Then in this case we have a limitation.The limitation is that array will always have a fixed size and once all the positions in the array are taken, once the array is exhausted, we have two options, we can either deny insertion, so we can say that the q is full and we cannot insert anything now or what we can do is we can create a new larger array and copy the elements from previous array to the new larger array which will be a costly process. We can avoid this problem if we will use linked list to implement q. Please note that this representation of circular array that I am showing here is only a logical way of looking at an array. We can show this array like this also.As I was saying in an array implementation, we will have this question, what if array gets filled and we need to take care of this. We can either say q is full or we can create a new larger array and copy elements from previous filled array into this new larger array. The time taken for this copy operation will be proportional to number of elements in filled array or in other words, we can say that the time complexity of this copy operation will be big O of n. There is another problem with array implementation, we can have a large enough array and q may not be using most of it.Like right now in this array, 90% of the memory is unused. Memory is an important resource and we should always avoid blocking memory unnecessarily. It's not that some amount of unused memory will be a real problem in a modern day machine.It's just that while designing solutions and algorithms, we should analyze and understand these implications. Let's now see how good we will be with a linked list implementation. I have drawn logical view of a linked list of integers here.Coming back to basic definition of q, as we know, a q is a list or collection with this constraint with this property that an element must always be inserted from one side of the q that we call the rear of q and an element must always be removed from the other side that we call.

ds-10

