
## 21、使用栈的中缀转后缀

在上节课中，我们学习了如何计算前缀和后缀表达式。这节课，我们将学习一种将中缀表达式转换为后缀表达式的高效算法。我们已经知道一种手动转换的方法，即运用运算符优先级和结合性规则来进行转换。现在，让我们来转换我在这里写的这个表达式。乘法运算符的优先级更高，因此我们会先转换这部分 B 星号 C。B 星号 C 会变成 BC 星号，运算符会出现在操作数前面。

现在我们可以对这个加法进行转换。对于加法，操作数是A和这个后缀表达式。在最后一步，我们可以去掉所有的括号。所以最终这就是我的后缀表达式。我们也可以在程序中使用这个逻辑，但它不会非常高效，实现也会有些复杂。我要讲一个真正简单高效的算法，在这个算法中，我们只需要从左到右解析一次中缀表达式，就可以创建出后缀表达式。

在中缀表达式转后缀表达式的过程中，操作数的位置和运算符的位置可能会发生变化，但操作数从左到右的顺序不会改变。运算符的顺序可能会发生变化。这是一个重要的观察结果。在这里的中缀和后缀形式中，操作数从左到右的顺序都是先有A，然后有B，最后有C，但运算符的顺序是不同的。在中缀表达式中，首先是加号，然后是乘号。

在后缀表达式中，乘法优先于加法。后缀表达式的运算符顺序始终与其执行顺序一致。我将再次演示这种转换，但这次会采用不同的逻辑方法。具体操作是从左到右解析中缀表达式，逐个检查每个标记——这些标记可能是操作数或运算符。以这个表达式为例，我们从A开始。A是操作数。遇到操作数时，可以直接将其附加到我们正在构建的后缀字符串或表达式中。

至少对于A来说，这一点应该非常明确：在A之前不可能出现任何内容。好的，那么第一条规则是，如果遇到操作数，我们可以直接将其放入后缀表达式中。接下来我们遇到一个运算符。由于尚未看到其右操作数，我们不能直接将运算符放入后缀表达式。在解析过程中，我们目前只看到了它的左操作数。只有在其右操作数也被放置后，我们才能放置这个运算符。

因此，我将把这个运算符单独保存在一个列表或集合中，稍后在可以放置时再将其放入后缀表达式中。而我将用于存储的结构是栈。栈只是一种特殊的列表，其中后进先出。插入和删除操作都发生在同一端。这里我已经将加号运算符压入栈中。接下来是操作数B。正如我们所说，操作数可以直接追加。在这个操作数之前不能有任何东西。栈中的运算符实际上是在等待操作数的到来。那么在这个阶段，我们是否可以将加法运算符放入后缀字符串中呢？实际上，B之后的内容也很重要。

在这种情况下，B后面跟着这个乘法运算符，它的优先级更高，所以加法的实际操作数是整个表达式B乘以C。在乘法完成之前，我们无法执行加法。因此，在解析时，当我处于B的位置，还没有看到B后面的内容时，我无法决定栈中运算符的命运。所以让我们继续前进。现在我们有了这个乘法运算符。为了让解释更清楚，我想让这个表达式变得更复杂一些。

所以我现在在这个表达式的末尾添加了一些内容。现在我想把这个表达式转换成后缀形式。我这里没有任何括号。我们稍后会看到如何处理括号。让我们来看一个括号不覆盖运算符优先级的表达式。好的，现在在这个表达式中，从左到右解析时，我们处于这个乘法运算符的位置。乘法运算符本身不能进入后缀表达式，因为我们还没有看到它的右操作数，直到它的右操作数被放置在后缀表达式中，我们才能放置它。

在解析过程中，我们正在查看的运算符本身并不能立即放置。但通过观察该运算符，我们可以决定是否将集合或堆栈中的某些内容放入我们正在构建的后缀表达式中。堆栈中优先级高于当前查看运算符的任何运算符都可以被弹出并放入后缀表达式。我们暂且按这个规则执行，稍后我会解释原因。当前栈中只有一个运算符，且其优先级不高于乘法运算符。因此我们不会将其弹出并放入后缀表达式中。乘法运算符本身会被压入栈中。如果栈中某个元素上方还有其他元素，那么上方的元素必定具有更高的优先级。现在让我们继续解析这个表达式。

现在我们到了C，它是一个操作数，所以可以直接输出。接下来我们遇到一个减法运算符。减法运算符本身不能直接输出。但正如我们之前所说，如果栈中有比当前运算符优先级更高的运算符，就应该将其弹出并输出。那么问题来了，为什么？我们将这些运算符压入栈中，而不是直接放入后缀表达式，因为我们不确定是否已经处理完右操作数。

但在那之后，一旦遇到优先级更低的运算符，就标志着右操作数的边界。对于这个乘法运算符来说，C就是我的右操作数，它只是一个简单的变量。而对于加法运算符来说，B乘以C就是我的右操作数。因为减法的优先级更低，所以在那之后或之后的内容都不能成为我的右操作数。准确地说，由于结合性规则，减法的优先级更低。

如果你记得运算顺序的话，加法和减法具有相同的优先级，但出现在左边的运算符会被优先处理。所以思路是，任何时候遇到一个运算符时，如果我得到一个优先级较低的运算符，就可以从栈中弹出它并放入表达式中。这里我们会先弹出乘法并放置，然后可以弹出加法，现在我们将减法压入栈中。

现在继续。D是一个操作数，所以直接输出。接下来遇到乘法运算符。栈中没有比乘法优先级更高的运算符，因此不弹出任何内容。乘法运算符将压入栈中。接着遇到一个操作数，直接输出。现在有两种方式可以确定运算符右操作数的结束位置：A是遇到优先级更低的运算符；B是到达表达式末尾。

既然我们已经到达表达式的末尾，我们可以简单地弹出并放置这些运算符。所以首先是乘法运算符，然后是减法运算符。让我们快速写下到目前为止我所说的伪代码，然后你可以通过一些例子坐下来分析逻辑。我将编写一个名为 infix to postfix 的函数，它将接受一个字符串 exp（表达式）作为参数。

为了简单起见，我们假设每个操作数或运算符仅由一个字符组成。在实际实现中，你可以假设它们是由多个字符组成的标记。因此，在我的伪代码中，我要做的第一件事是创建一个名为S的字符栈。现在，我将运行一个从0开始到表达式长度减1的循环。这样我就能逐个查看每个字符，它可能是操作数或运算符。

如果字符是操作数，我们可以将其附加到后缀字符串中。实际上，我应该在循环之前声明并初始化一个字符串。这是我将要附加的结果字符串。否则，如果表达式I是运算符，我们需要在堆栈中寻找具有更高优先级的运算符。所以我会说，当堆栈不为空且堆栈顶部具有更高优先级时，假设这个函数hasHigherPrecedence将接受两个参数，即两个运算符。

因此，如果栈顶运算符的优先级高于当前扫描的运算符，我们就可以将栈顶运算符追加到结果变量（即存储后缀表达式的字符串）中，然后弹出该运算符。这里假设S是某个实现了stop、pop和empty方法（用于检查栈是否为空）的类。最后，在while循环外部完成弹出操作后，需要将当前运算符压入栈中。S是某个类的对象，它将具有这些函数：Stop、pop和empty。好的，这是我的for循环的结尾。在循环结束时，我可能在栈中还有一些运算符。我将弹出这些运算符并将它们附加到后缀字符串中。我会使用这个while循环。

我会说，当栈不为空时，将顶部的操作符追加并弹出，最后在这个while循环之后，我可以返回结果字符串，其中将包含我的后缀表达式。这就是我目前为止解释的逻辑的伪代码。在我的逻辑中，我没有处理括号。如果我的中缀表达式带有这样的括号怎么办？与我们之前所做的会有些许变化。有了括号后，表达式中的任何括号内的部分都应被视为独立的完整表达式，括号外的任何元素都不会影响其执行。在这个表达式中，这部分A加B位于一个括号内。它的执行不会受到括号外的这个乘法或减法的影响。

同样地，整个这部分都在外层的括号内。因此，外面的乘法运算符不会对这一部分的整体执行产生任何影响。如果括号是嵌套的，内层括号会先被处理或解析，然后才能解析外层括号。对于括号，我们会有一些额外的规则。我们仍然会从左到右进行，仍然会使用堆栈，假设我会在这里写下我创建的后缀部分。

在解析过程中，一个标记可以是一个操作数、一个运算符，或者是一个开括号或闭括号。我们会有一些额外的规则。我会先说明这些规则，然后再进行解释。如果遇到开括号，我们可以将其压入堆栈。在这个例子中，第一个标记是一个开括号，所以它会被压入堆栈，然后我们继续。我们又遇到了一个开括号，所以再次将其压入堆栈。现在我们有一个操作数。对于操作数，规则没有变化。

它将被简单地附加到后缀部分。接下来我们有一个运算符。还记得我们之前对运算符的处理方式吗？我们会查看栈顶，只要遇到更高优先级的运算符就持续弹出。之前在不使用括号的情况下，我们可以一直弹出直到清空栈，但现在我们需要查看栈顶，并且只在遇到开括号时才停止弹出，因为如果我们遇到开括号，那就意味着这是最后一个开括号的边界，此运算符在此之后就不再有任何影响了。

所以这个加号运算符在左括号之外没有任何影响。稍后我会用更多例子来解释这个场景。首先我们来理解规则。规则是，如果我看到一个运算符，我需要查看栈顶。如果它是一个优先级更高的运算符，我可以弹出它，然后我应该查看下一个栈顶元素。如果再次遇到优先级更高的运算符，我应该再次弹出，但当我看到一个左括号时就应该停止。

现阶段，顶部有一个左括号，因此我们无需查看其下方内容。无论如何都不会有元素弹出。但加法运算符会被压入堆栈。记住，在完成所有弹出操作后，我们还要将运算符本身压入堆栈。接下来遇到一个操作数，它会直接进入堆栈，然后我们继续处理。随后遇到一个右括号。当我遇到右括号时，就意味着最近打开的括号在逻辑上到达了终点。

对于括号内的这部分表达式，它即将结束，还记得我们之前处理中缀表达式结束时所做的操作吗？我们当时将所有运算符弹出并放置。因此，这次我们也需要弹出所有运算符，但仅限于属于我们正在关闭的这个括号内的那些运算符。因此，我们需要弹出所有运算符，直到遇到一个开括号。我现在弹出这个加号并附加它。接下来我们遇到一个开括号，所以我会停止，但作为最后一步，我也会弹出这个开括号，因为这对括号的处理已经完成。好的，所以对于闭括号的规则是：一直弹出运算符，直到遇到一个开括号，最后也要弹出那个特定的开括号。现在让我们继续。接下来我们有一个运算符。

我们需要查看栈顶元素。这是一个左括号。这个运算符会被直接压入栈中。接下来我们遇到一个操作数。然后是一个运算符。我们再次查看栈顶元素。发现乘法运算符的优先级更高。因此应该将其弹出并附加到结果中。我们会再次查看栈顶元素。这是一个左括号的开始，所以我们现在应该停止查找。减号现在会被压入。接下来我们有一个操作数。然后我们有一个右括号的结束。所以我们需要弹出直到遇到一个左括号。减号会被附加。

最后，开括号也会被弹出。接下来我们有一个运算符，它会简单地被处理。然后我们有一个操作数，现在我们已经到达表达式的末尾。因此，堆栈中的所有内容都将被弹出并附加。所以最终这就是我的后缀表达式。我会再举一个例子并进行转换，以使事情更加清楚。我想转换这个表达式。我会从头开始。首先我们有一个操作数。

然后这个乘法运算符将简单地进入堆栈。现在堆栈是空的。顶部没有任何内容需要转换。我们将继续，接下来有一个操作数，它会被追加，现在我们转到这个加法运算符。如果这个开括号不在那里，堆栈的顶部将是乘法运算符，它的优先级更高，所以它会被弹出，但现在我们看顶部，它是一个开括号，所以我们不能往下看，只能继续。接下来我们有C，我上次忘了把加法运算符压入堆栈。

好的，在C之后，我们遇到了这个闭括号，所以需要不断弹出栈顶元素直到遇到对应的开括号，然后还需要再弹出一个开括号。最后，我们已经到达表达式的末尾，因此栈中的所有元素都会被弹出并附加到结果中。这样最终就得到了我的后缀部分，也就是后缀表达式形式。在我之前写的伪代码中，只有这个for循环内的部分需要修改以处理括号的情况。如果我们遇到一个运算符，需要查看栈顶元素并弹出，但只在我们遇到开括号之前才这样做，所以我在while循环中额外添加了这个条件。

这个条件将确保我们在遇到左括号时停止。目前，在for循环中，我们正在处理操作数和运算符。我们还将有两个条件。如果是左括号，我们应该压入栈；如果是右括号，我们可以继续弹出并追加。假设这个函数是左括号，我们将检查一个字符是否是左括号。

事实上，在这里检查当前标记是否为开头时，我们也应该使用这个函数，因为它可能是开大括号或开括号。这个函数会负责处理。可以说这个函数会搞定。同样地，对于最后一个else if，我们应该使用这个函数来判断是否为闭括号。好了，现在逻辑一致了。在这个while循环之后的最后一个else if里，我们应该额外执行一次pop操作，这次额外的pop会弹出开括号。现在我们完成了这个else if，这也是我的for循环的结束部分。其余部分保持不变。

在for循环之后，我们可以弹出剩余部分并附加到字符串中，最后返回结果。这就是我最终的伪代码。你可以查看本视频描述中的链接，获取实际实现的源代码。好的，我就讲到这里。本节课的内容就这些。感谢观看。

## 22、队列

大家好。我们已经讨论了一段时间的数据结构。众所周知，数据结构是计算机中存储和组织数据的方式。在本系列中，我们已经讨论了数组、链表等数据结构，并在最近几节课中讲解了栈的概念。本节课我们将向大家介绍队列。我们会像讲解栈时那样，先讨论队列的抽象数据类型（ADT）。我们知道，当我们将某个数据结构视为抽象数据类型时，只定义该数据结构可用的功能或操作，而不涉及具体实现细节。

我们将在后续课程中探讨具体的实现方法。本节课我们仅讨论队列数据结构的逻辑概念。好的，现在开始讲解。队列数据结构正如其名，与我们日常生活中排队的含义完全一致。队列是一种先进先出的结构，简称为 FIFO 结构。之前我们学习过栈结构，它是一种后进先出的结构，简称 LIFO。栈是一种集合数据结构，其插入和删除操作都发生在同一端，我们称之为栈顶。而队列则不同，插入操作必须发生在称为队尾的一端，删除操作则必须发生在另一端，我们称之为队头。

如果要从形式上把队列定义为一个抽象数据类型，那么队列就是一种具有限制条件的列表或集合：插入操作只能且必须在称为队尾的一端进行，而删除操作则只能在称为队头或队首的另一端执行。现在我们来定义队列支持的接口或操作。与栈类似，队列也有两个基本操作：插入操作称为入队（enqueue），也有人喜欢称之为压入（push）。入队操作应在队列的尾部插入一个元素。

删除操作被称为出队操作。在某些实现中，人们也把这个操作称为弹出。在栈的上下文中，压入和弹出更为人熟知。而在队列的上下文中，入队和出队更为常见。在实现时，你可以在接口中选择使用这些名称中的任何一个。出队操作应该从队列的前端或头部移除一个元素，并且通常还会返回这个从头部移除的元素。对于一个整数队列来说，入队和出队的函数签名可以像这样。

这里的入队操作返回void，而出队操作返回一个整数。这个整数应该是从队列中移除的元素。你也可以将出队操作设计为返回void。通常我们会保留第三个操作front或peak，仅用于查看队列头部的元素，就像我们在栈中保留的top操作一样。这个操作应该只返回前端的元素，而不删除任何内容。好的，我们还可以增加一些操作。我们可以有一个操作来检查队列是否为空。如果队列的大小有限制，那么我们还可以有一个操作来检查队列是否已满。

我之所以要指出这些操作的不同名称，也是因为大多数时候我们并不需要自己实现数据结构。我们使用语言库中内置的实现。不同语言库的接口可能有所不同。例如，如果你使用C++内置的队列，插入的函数是push，而在C#中则是enqueue。所以我们不应该混淆。我就把更知名的名字放在这里。好的，这些是我为队列ADT定义的操作：入队（enqueue）、出队（dequeue）、查看队首（front）和判空（isEmpty）。我们可以通过入队和出队操作每次在队列中插入或移除一个元素，查看队首仅用于观察头部元素，判空则用于验证队列是否为空。我在这里写的所有这些操作都必须以恒定时间完成，换句话说，它们的时间复杂度应该是O(1)。从逻辑上讲，队列可以表示为一个两端开放的图形或容器。

因此，元素可以从一端插入（入队），而从另一端移除（出队）。如果你还记得栈的话，我们曾将栈描述为一个仅一端开放的容器。在栈的语境中，插入（我们称之为压入）和移除（弹出）都必须发生在同一端；而在队列中，插入和移除应当发生在不同的两端。假设我想创建一个整数队列。初始时我们有一个空队列，我会先写下其中一个操作，然后在逻辑视图中向你展示模拟过程。假设我首先想将数字2入队。

我现在展示的这个图是一个空的整数队列。我正在这里执行一个入队操作。在程序中，我会调用一个入队函数，并将数字2作为参数传递给它。这次入队后，队列中就有了一个元素，即一个整数。因为目前队列中只有一个元素，所以队列的前端和后端是相同的。让我们再入队一个整数。现在我想插入数字5，5将被插入到队列的后端或尾部。让我们再入队一个。现在我想调用出队操作。

因此我们将从队列头部取出两个元素并将其移除。如果出队操作需要返回这个被移除的整数，那么我们将得到整数二作为返回值。入队和出队是队列的基本操作。在我们的设计中，为了方便起见还可以添加更多功能。比如这里我们提供了获取队首元素和判空功能——在当前阶段调用获取队首元素会返回数字五（整数五），但不会从队列中移除任何元素。此时调用判空函数会返回布尔值false，或者用0表示false，1表示true。以上就是队列的基本运作原理。

现在一个显而易见的问题是，在哪些实际场景中我们可以使用队列？队列数据结构有哪些应用案例？队列最常用于存在共享资源需要处理某些请求的场景中。但该资源一次只能处理一个请求，同一时间只能服务一个请求。在这种情况下，最合理的做法是将请求排队，先到的请求先得到服务。假设我们有一个网络共享的打印机，网络中的任何机器都可以向这台打印机发送打印请求。打印机一次只能处理一个请求，同一时间只能打印一份文件。因此，如果它在忙碌时收到请求，它不能直接说“我很忙，稍后再请求”，那样对打印机来说就太粗鲁了。实际上发生的是，管理打印机的程序会将打印请求放入一个队列中。

只要队列中有内容，打印机就会不断从队列前端取出请求并处理。你电脑上的处理器也是一种共享资源。许多正在运行的程序或进程都需要处理器的时间，但处理器一次只能处理一个进程。处理器就是那个必须执行所有指令、完成所有算术和逻辑运算的家伙。因此，这些进程会被放入队列中。队列通常可用于模拟多种场景中的权重。在后续课程中解决一些问题时，我们将详细讨论队列的这些应用。作为入门介绍，这部分内容已经足够。下节课我们将学习如何实现队列。本节课的内容就到这里。感谢观看。

在上节课中，我们向大家介绍了队列数据结构。我们讨论了队列作为一种抽象数据类型（ADT）。


## 23、用数组实现队列

众所周知，当我们把数据结构作为一种抽象数据类型来讨论时，我们将其定义为一种数学或逻辑模型。我们只定义数据结构可用的特性或操作，而不涉及实现细节。在本课中，我们将讨论队列的可能实现方式。

我将快速回顾一下我们目前讨论的内容。队列是一种具有特定限制的列表或集合，其约束条件为：插入操作只能在称为队列尾部的一端进行，而删除操作只能在称为队列头部的一端进行。在队列中，插入操作被称为入队操作，删除操作则被称为出队操作。

我已经在这里定义了队列的抽象数据类型（ADT），包含这四个操作。在实际实现中，所有这些操作都将是函数。Front操作应该简单地返回队列前端的元素，而不应该从队列中移除任何元素。isEmpty操作只需检查队列是否为空。所有这些操作必须在常数时间内完成，无论是出队操作还是查看前端元素，这些操作所花费的时间都不能依赖于变量，比如队列中元素的数量。换句话说，所有这些操作的时间复杂度都必须是O(1)。

好的，我们开始吧。队列是一种特殊的列表，其中的元素只能逐个插入或移除，且插入和移除操作分别在队列的两端进行。我们可以在队列的一端插入元素，在另一端移除元素，这与栈的操作方式类似。我们可以通过为列表添加这些约束或额外属性来实现队列。队列有两种常见的实现方式：一种是基于数组的实现，另一种是基于链表的实现。

让我们先讨论基于数组的实现。假设我们要创建一个整数队列。我们可以先创建一个整数数组。这里我创建了一个包含10个整数的数组，并将其命名为A。现在，我将使用这个数组来存储我的队列。我的做法是，在任何时刻，数组的一部分，从标记为front的索引开始，到标记为rear的索引结束，这部分就是我的队列。

在这个数组中，我将队列的前端显示在左侧，后端显示在右侧。在之前的例子中，我将前端显示在右侧，后端显示在左侧，这其实无关紧要。任何一边都可以作为前端，任何一边也可以作为后端。关键是要始终从后端添加元素，从前端移除元素。因此，在任何阶段，数组中从前端标记的索引到后端标记的索引之间的部分就是我的队列，数组中的其余位置则是可以用来扩展队列的空闲空间。

要将元素插入队列的末尾，我们可以增加尾部指针。因此，我们将在队列的尾部添加一个新的单元格，并在该单元格中写入新值。要插入的元素可以到达这个位置。我会在这些位置填入一些值。因此，队列中有这些整数，假设我们要插入数字5。为了插入，我们将增加尾部指针。当然，右侧应该有一个可用的单元格和一个空的单元格，现在我们可以在这里写入值5。

插入后，新的尾部索引是7，索引7处的值为5。现在执行出队操作意味着我们必须从队列的前端移除一个元素。在这个例子中，出队操作应该从队列中移除数字2。为了执行出队操作，我们可以简单地增加前端索引，因为在任何时候，只有从前端索引到尾部索引的单元格才是队列的一部分。通过增加前端索引，我已经将索引2从队列中移除，我们不需要关心不属于队列的单元格中存储的值。

当我们将一个单元格加入队列时，无论如何都会覆盖该单元格中的值。因此，对于出队操作来说，只需增加front就足够了。让我们快速为目前为止讨论的内容编写伪代码。在我的代码中，我将有两个变量，名为front和rear，最初我会将它们都设置为-1。假设对于一个空队列，front和rear都为-1。要检查队列是否为空，我们可以简单地检查front和rear的值，如果它们都为-1，我们就可以说队列为空。我刚刚在这里写了isEmpty函数。

-1 不是一个有效的索引。对于空队列来说，不存在队首和队尾。在我们的实现中，我们规定通过将队首和队尾都设为-1来表示队列的空状态。现在让我们来编写入队函数。入队函数将接收一个整数x作为参数。入队操作需要考虑几种情况。如果队尾已经等于数组A中的最大可用索引，我们就无法再插入或入队元素。在这种情况下，我们可以直接返回并退出。我更倾向于使用一个名为isFull的函数来判断队列是否已满。

如果队列已满，我们无能为力，只能直接退出。如果队列为空，我们可以向队列中添加一个单元格，即在索引0处添加单元格，并将rear索引处的值设为x。其他情况下，我们可以先递增rear，然后在rear索引处填入值x。我可以将这条语句“rear等于x”放在这两个条件语句之外，因为这对它们来说是通用的。

这就是我的入队函数。在我展示的这个示例数组中，让我们入队一些整数。我将调用入队函数，并在图中展示模拟过程。假设首先我想在队列中插入数字2。我调用入队函数，将数字2作为参数传入。队列是空的，所以我们将front和rear都设为0。现在我们将执行这条语句。我们将在索引0处写入值2。这就是执行一次入队操作后我的队列状态。

队列的前端和后端是相同的。让我们再调用一次入队操作。这次我想插入数字5。此时队列不为空，因此后端指针会递增。我们通过递增后端指针向队列添加了一个单元，现在将在新的后端索引处写入值5。让我们再入队一个数字。我已经将7入队。现在让我们编写出队操作。出队操作会有几种情况。如果队列已经为空，我们就无法移除元素。

在这种情况下，我们可以直接打印或抛出错误并返回或退出。还有一种特殊情况：如果队列中只有一个元素，此时 front 和 rear 不会等于 -1，而是彼此相等，因为我们在之前的 if 语句中已经通过 isEmpty 函数检查了 -1 的情况。在这个 else if 中，我们只需检查 front 是否等于 rear。如果满足条件，执行出队操作将使队列变为空，为了标记队列为空，我们需要将 front 和 rear 都设为 -1。

我们之前说过，表示空队列的方式是将 front 和 rear 都标记为 -1。在默认或正常情况下，我们只需递增 front 的值。在任何实现中，我们都必须特别注意边界情况，因为大多数错误都源于此。好了，这就是最终的出队函数。在这个例子中，假设当前阶段我们要执行出队操作。队列不为空，并且队列中不止一个元素，因此我们只需递增 front 的值。

在递增之前，我们可以将索引0处单元格的值设为任意内容，但已不属于队列的单元格中的值实际上无关紧要。在此阶段，除了队首和队尾之间的区段外，索引0、索引3或其他任何索引处的值都无关紧要。当我们向队列中添加单元格时，无论如何都会覆盖该单元格中的值。现在让我们执行更多的入队和出队操作。我将3入队，然后再将1入队。

每次入队时，我们都会增加rear的值。我刚才又进行了一些入队操作。现在让我们执行一次出队操作。如果我在这里再进行一次入队操作，rear将等于数组中可用的最大索引。让我们再入队一个元素。现在在这个阶段，我们无法再入队元素了，因为我们无法再增加rear的值。此时入队操作将会失败。现在有两个未使用的单元格，但根据我们编写的逻辑，我们无法使用位于front左侧的这两个单元格。

事实上，这是一个真实存在的问题，因为我们会不断出队。队首索引左侧的所有单元格将永远不会再被使用，它们只会被白白浪费。我们能否采取一些措施来利用这些单元格呢？其实，我们可以运用循环数组的概念。循环数组是一种我们在许多场景中都会用到的思路。这个想法非常简单：当我们遍历数组时，可以想象数组是没有尽头的。从0出发可以到达1，从1又可以到达2。

最后，当我们到达数组的最后一个索引时，就像这个例子中，当我们处于索引9时，下一个索引对我来说就是索引0。我们可以把数组想象成这样。记住，这只是看待数组的一种逻辑方式。在数组的循环解释中，如果我指向一个位置，当前的位置是i，那么下一个位置或下一个索引将不仅仅是i加1。它将是i加1对数组元素数量或数组大小取模。假设n是数组中的元素数量。

那么下一个位置将是i加1对n取模。取模运算可以得到除以n后的余数。对于除了n减1之外的任何i，这个取模运算不会有任何影响。但当i等于n减1时，下一个位置将是n对n取模，结果等于0。当你用一个数除以它自己时，余数为0。在数组的循环解释中，前一个位置将是i加n减1对n取模。为了确保括号内的表达式始终为正数，我们可以简单地说i减1对n取模。

我在这里加个n。仔细想想，你应该能明白为什么应该是i加n减1模n。现在有了这个数组的解释，只要数组中还有未使用的单元格，我们就可以在入队操作中增加rear。我现在要修改伪代码中的函数。Is empty保持不变。我们仍然认为对于一个空队列，front和rear会是-1。

让我们向下滚动，来到入队操作。在循环解释中，当rear的下一个位置（我们通过rear加1取模n来计算）等于front时，我将认为队列已满。这样就会出现这样的情况。目前，在循环解释中rear的下一个位置就是front。因此没有未使用的单元格，整个数组已经耗尽，在这种情况下不会发生任何变化。如果队列为空，我们可以简单地将front和rear设置为零。

在最后的else条件中，我们会这样递增rear指针：rear等于rear加1对n取模，其中n是数组中的元素数量。经过这样的修改，我的入队函数就完成了。现在让我们调用入队函数，向这个数组中插入一些内容。我想插入数字15。我们会进入最后的else条件。当前的rear指针是9。所以这个表达式将是9加1对n取模，这里的n是10，即数组a的大小为10，计算结果为零。现在我的新rear指针是0，我将在这里写入数字15。

现在来看看队列函数中需要做什么。前两个条件保持不变。如果队列已经是空的，或者队列中只有一个元素，我们将以同样的方式处理这些情况。在最后的else中，当我们要递增front时，需要以循环的方式递增。因此，我们将设置front等于front加1对n取模，其中n是数组中元素的总数，即数组的大小或数组中元素的总数。

现在我们来执行一个出队操作，此时front的值为2。因此计算方式为2加1再对10取模。这样我们又有一个新的单元格可用了。以上就是我们实现的核心部分。front操作非常简单，我们只需要返回front索引处的元素即可。同样地，这里我们也需要先检查队列是否为空，只有当front不等于-1时才返回front元素。我在这里写的所有这些操作、所有这些函数的时间复杂度都是常数级别的，即大O表示法中的O(1)。

我们在函数中进行简单的算术和赋值操作，并没有执行像运行循环这样的高成本操作。因此，所花费的时间不会取决于q的大小或其他变量。我就说到这里。将这个伪代码转换为你选择的语言中的可运行程序应该不会太难。如果你想看我的代码，可以查看这个视频描述中的链接。感谢观看。


## 24、

在上节课中，我们看到了如何使用数组来实现q。


Now in this lesson we will see how we can implement q using linked list. Q as we know from our previous discussions is a structure in which whatever goes in first comes out first. Q data structure is a list or collection with this restriction that insertion can be performed at one end and deletion can be performed at other end.These are typical operations that we define with q and insertion is called in q operation and deletion is called dq. Front operation, front function should simply return the element at front of list and is empty should check whether q is empty or not. And all these operations must take constant time, their time complexity should be big O of 1. When we were implementing q with arrays, we used the idea of a circular array to implement q. Then in this case we have a limitation.The limitation is that array will always have a fixed size and once all the positions in the array are taken, once the array is exhausted, we have two options, we can either deny insertion, so we can say that the q is full and we cannot insert anything now or what we can do is we can create a new larger array and copy the elements from previous array to the new larger array which will be a costly process. We can avoid this problem if we will use linked list to implement q. Please note that this representation of circular array that I am showing here is only a logical way of looking at an array. We can show this array like this also.As I was saying in an array implementation, we will have this question, what if array gets filled and we need to take care of this. We can either say q is full or we can create a new larger array and copy elements from previous filled array into this new larger array. The time taken for this copy operation will be proportional to number of elements in filled array or in other words, we can say that the time complexity of this copy operation will be big O of n. There is another problem with array implementation, we can have a large enough array and q may not be using most of it.Like right now in this array, 90% of the memory is unused. Memory is an important resource and we should always avoid blocking memory unnecessarily. It's not that some amount of unused memory will be a real problem in a modern day machine.It's just that while designing solutions and algorithms, we should analyze and understand these implications. Let's now see how good we will be with a linked list implementation. I have drawn logical view of a linked list of integers here.Coming back to basic definition of q, as we know, a q is a list or collection with this constraint with this property that an element must always be inserted from one side of the q that we call the rear of q and an element must always be removed from the other side that we call.

ds-10

