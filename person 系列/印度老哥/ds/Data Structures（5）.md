
## 21、使用栈的中缀转后缀

在上节课中，我们学习了如何计算前缀和后缀表达式。这节课，我们将学习一种将中缀表达式转换为后缀表达式的高效算法。我们已经知道一种手动转换的方法，即运用运算符优先级和结合性规则来进行转换。现在，让我们来转换我在这里写的这个表达式。乘法运算符的优先级更高，因此我们会先转换这部分 B 星号 C。B 星号 C 会变成 BC 星号，运算符会出现在操作数前面。

现在我们可以对这个加法进行转换。对于加法，操作数是A和这个后缀表达式。在最后一步，我们可以去掉所有的括号。所以最终这就是我的后缀表达式。我们也可以在程序中使用这个逻辑，但它不会非常高效，实现也会有些复杂。我要讲一个真正简单高效的算法，在这个算法中，我们只需要从左到右解析一次中缀表达式，就可以创建出后缀表达式。

在中缀表达式转后缀表达式的过程中，操作数的位置和运算符的位置可能会发生变化，但操作数从左到右的顺序不会改变。运算符的顺序可能会发生变化。这是一个重要的观察结果。在这里的中缀和后缀形式中，操作数从左到右的顺序都是先有A，然后有B，最后有C，但运算符的顺序是不同的。在中缀表达式中，首先是加号，然后是乘号。

在后缀表达式中，乘法优先于加法。后缀表达式的运算符顺序始终与其执行顺序一致。我将再次演示这种转换，但这次会采用不同的逻辑方法。具体操作是从左到右解析中缀表达式，逐个检查每个标记——这些标记可能是操作数或运算符。以这个表达式为例，我们从A开始。A是操作数。遇到操作数时，可以直接将其附加到我们正在构建的后缀字符串或表达式中。

至少对于A来说，这一点应该非常明确：在A之前不可能出现任何内容。好的，那么第一条规则是，如果遇到操作数，我们可以直接将其放入后缀表达式中。接下来我们遇到一个运算符。由于尚未看到其右操作数，我们不能直接将运算符放入后缀表达式。在解析过程中，我们目前只看到了它的左操作数。只有在其右操作数也被放置后，我们才能放置这个运算符。

因此，我将把这个运算符单独保存在一个列表或集合中，稍后在可以放置时再将其放入后缀表达式中。而我将用于存储的结构是栈。栈只是一种特殊的列表，其中后进先出。插入和删除操作都发生在同一端。这里我已经将加号运算符压入栈中。接下来是操作数B。正如我们所说，操作数可以直接追加。在这个操作数之前不能有任何东西。栈中的运算符实际上是在等待操作数的到来。那么在这个阶段，我们是否可以将加法运算符放入后缀字符串中呢？实际上，B之后的内容也很重要。

在这种情况下，B后面跟着这个乘法运算符，它的优先级更高，所以加法的实际操作数是整个表达式B乘以C。在乘法完成之前，我们无法执行加法。因此，在解析时，当我处于B的位置，还没有看到B后面的内容时，我无法决定栈中运算符的命运。所以让我们继续前进。现在我们有了这个乘法运算符。为了让解释更清楚，我想让这个表达式变得更复杂一些。

所以我现在在这个表达式的末尾添加了一些内容。现在我想把这个表达式转换成后缀形式。我这里没有任何括号。我们稍后会看到如何处理括号。让我们来看一个括号不覆盖运算符优先级的表达式。好的，现在在这个表达式中，从左到右解析时，我们处于这个乘法运算符的位置。乘法运算符本身不能进入后缀表达式，因为我们还没有看到它的右操作数，直到它的右操作数被放置在后缀表达式中，我们才能放置它。

在解析过程中，我们正在查看的运算符本身并不能立即放置。但通过观察该运算符，我们可以决定是否将集合或堆栈中的某些内容放入我们正在构建的后缀表达式中。堆栈中优先级高于当前查看运算符的任何运算符都可以被弹出并放入后缀表达式。我们暂且按这个规则执行，稍后我会解释原因。当前栈中只有一个运算符，且其优先级不高于乘法运算符。因此我们不会将其弹出并放入后缀表达式中。乘法运算符本身会被压入栈中。如果栈中某个元素上方还有其他元素，那么上方的元素必定具有更高的优先级。现在让我们继续解析这个表达式。

现在我们到了C，它是一个操作数，所以可以直接输出。接下来我们遇到一个减法运算符。减法运算符本身不能直接输出。但正如我们之前所说，如果栈中有比当前运算符优先级更高的运算符，就应该将其弹出并输出。那么问题来了，为什么？我们将这些运算符压入栈中，而不是直接放入后缀表达式，因为我们不确定是否已经处理完右操作数。

但在那之后，一旦遇到优先级更低的运算符，就标志着右操作数的边界。对于这个乘法运算符来说，C就是我的右操作数，它只是一个简单的变量。而对于加法运算符来说，B乘以C就是我的右操作数。因为减法的优先级更低，所以在那之后或之后的内容都不能成为我的右操作数。准确地说，由于结合性规则，减法的优先级更低。

如果你记得运算顺序的话，加法和减法具有相同的优先级，但出现在左边的运算符会被优先处理。所以思路是，任何时候遇到一个运算符时，如果我得到一个优先级较低的运算符，就可以从栈中弹出它并放入表达式中。这里我们会先弹出乘法并放置，然后可以弹出加法，现在我们将减法压入栈中。

现在继续。D是一个操作数，所以直接输出。接下来遇到乘法运算符。栈中没有比乘法优先级更高的运算符，因此不弹出任何内容。乘法运算符将压入栈中。接着遇到一个操作数，直接输出。现在有两种方式可以确定运算符右操作数的结束位置：A是遇到优先级更低的运算符；B是到达表达式末尾。

既然我们已经到达表达式的末尾，我们可以简单地弹出并放置这些运算符。所以首先是乘法运算符，然后是减法运算符。让我们快速写下到目前为止我所说的伪代码，然后你可以通过一些例子坐下来分析逻辑。我将编写一个名为 infix to postfix 的函数，它将接受一个字符串 exp（表达式）作为参数。

为了简单起见，我们假设每个操作数或运算符仅由一个字符组成。在实际实现中，你可以假设它们是由多个字符组成的标记。因此，在我的伪代码中，我要做的第一件事是创建一个名为S的字符栈。现在，我将运行一个从0开始到表达式长度减1的循环。这样我就能逐个查看每个字符，它可能是操作数或运算符。

如果字符是操作数，我们可以将其附加到后缀字符串中。实际上，我应该在循环之前声明并初始化一个字符串。这是我将要附加的结果字符串。否则，如果表达式I是运算符，我们需要在堆栈中寻找具有更高优先级的运算符。所以我会说，当堆栈不为空且堆栈顶部具有更高优先级时，假设这个函数hasHigherPrecedence将接受两个参数，即两个运算符。

因此，如果栈顶运算符的优先级高于当前扫描的运算符，我们就可以将栈顶运算符追加到结果变量（即存储后缀表达式的字符串）中，然后弹出该运算符。这里假设S是某个实现了stop、pop和empty方法（用于检查栈是否为空）的类。最后，在while循环外部完成弹出操作后，需要将当前运算符压入栈中。S是某个类的对象，它将具有这些函数：Stop、pop和empty。好的，这是我的for循环的结尾。在循环结束时，我可能在栈中还有一些运算符。我将弹出这些运算符并将它们附加到后缀字符串中。我会使用这个while循环。

我会说，当栈不为空时，将顶部的操作符追加并弹出，最后在这个while循环之后，我可以返回结果字符串，其中将包含我的后缀表达式。这就是我目前为止解释的逻辑的伪代码。在我的逻辑中，我没有处理括号。如果我的中缀表达式带有这样的括号怎么办？与我们之前所做的会有些许变化。有了括号后，表达式中的任何括号内的部分都应被视为独立的完整表达式，括号外的任何元素都不会影响其执行。在这个表达式中，这部分A加B位于一个括号内。它的执行不会受到括号外的这个乘法或减法的影响。

同样地，整个这部分都在外层的括号内。因此，外面的乘法运算符不会对这一部分的整体执行产生任何影响。如果括号是嵌套的，内层括号会先被处理或解析，然后才能解析外层括号。对于括号，我们会有一些额外的规则。我们仍然会从左到右进行，仍然会使用堆栈，假设我会在这里写下我创建的后缀部分。

在解析过程中，一个标记可以是一个操作数、一个运算符，或者是一个开括号或闭括号。我们会有一些额外的规则。我会先说明这些规则，然后再进行解释。如果遇到开括号，我们可以将其压入堆栈。在这个例子中，第一个标记是一个开括号，所以它会被压入堆栈，然后我们继续。我们又遇到了一个开括号，所以再次将其压入堆栈。现在我们有一个操作数。对于操作数，规则没有变化。

它将被简单地附加到后缀部分。接下来我们有一个运算符。还记得我们之前对运算符的处理方式吗？我们会查看栈顶，只要遇到更高优先级的运算符就持续弹出。之前在不使用括号的情况下，我们可以一直弹出直到清空栈，但现在我们需要查看栈顶，并且只在遇到开括号时才停止弹出，因为如果我们遇到开括号，那就意味着这是最后一个开括号的边界，此运算符在此之后就不再有任何影响了。

所以这个加号运算符在左括号之外没有任何影响。稍后我会用更多例子来解释这个场景。首先我们来理解规则。规则是，如果我看到一个运算符，我需要查看栈顶。如果它是一个优先级更高的运算符，我可以弹出它，然后我应该查看下一个栈顶元素。如果再次遇到优先级更高的运算符，我应该再次弹出，但当我看到一个左括号时就应该停止。

现阶段，顶部有一个左括号，因此我们无需查看其下方内容。无论如何都不会有元素弹出。但加法运算符会被压入堆栈。记住，在完成所有弹出操作后，我们还要将运算符本身压入堆栈。接下来遇到一个操作数，它会直接进入堆栈，然后我们继续处理。随后遇到一个右括号。当我遇到右括号时，就意味着最近打开的括号在逻辑上到达了终点。

对于括号内的这部分表达式，它即将结束，还记得我们之前处理中缀表达式结束时所做的操作吗？我们当时将所有运算符弹出并放置。因此，这次我们也需要弹出所有运算符，但仅限于属于我们正在关闭的这个括号内的那些运算符。因此，我们需要弹出所有运算符，直到遇到一个开括号。我现在弹出这个加号并附加它。接下来我们遇到一个开括号，所以我会停止，但作为最后一步，我也会弹出这个开括号，因为这对括号的处理已经完成。好的，所以对于闭括号的规则是：一直弹出运算符，直到遇到一个开括号，最后也要弹出那个特定的开括号。现在让我们继续。接下来我们有一个运算符。

我们需要查看栈顶元素。这是一个左括号。这个运算符会被直接压入栈中。接下来我们遇到一个操作数。然后是一个运算符。我们再次查看栈顶元素。发现乘法运算符的优先级更高。因此应该将其弹出并附加到结果中。我们会再次查看栈顶元素。这是一个左括号的开始，所以我们现在应该停止查找。减号现在会被压入。接下来我们有一个操作数。然后我们有一个右括号的结束。所以我们需要弹出直到遇到一个左括号。减号会被附加。

最后，开括号也会被弹出。接下来我们有一个运算符，它会简单地被处理。然后我们有一个操作数，现在我们已经到达表达式的末尾。因此，堆栈中的所有内容都将被弹出并附加。所以最终这就是我的后缀表达式。我会再举一个例子并进行转换，以使事情更加清楚。我想转换这个表达式。我会从头开始。首先我们有一个操作数。

然后这个乘法运算符将简单地进入堆栈。现在堆栈是空的。顶部没有任何内容需要转换。我们将继续，接下来有一个操作数，它会被追加，现在我们转到这个加法运算符。如果这个开括号不在那里，堆栈的顶部将是乘法运算符，它的优先级更高，所以它会被弹出，但现在我们看顶部，它是一个开括号，所以我们不能往下看，只能继续。接下来我们有C，我上次忘了把加法运算符压入堆栈。

好的，在C之后，我们遇到了这个闭括号，所以需要不断弹出栈顶元素直到遇到对应的开括号，然后还需要再弹出一个开括号。最后，我们已经到达表达式的末尾，因此栈中的所有元素都会被弹出并附加到结果中。这样最终就得到了我的后缀部分，也就是后缀表达式形式。在我之前写的伪代码中，只有这个for循环内的部分需要修改以处理括号的情况。如果我们遇到一个运算符，需要查看栈顶元素并弹出，但只在我们遇到开括号之前才这样做，所以我在while循环中额外添加了这个条件。

这个条件将确保我们在遇到左括号时停止。目前，在for循环中，我们正在处理操作数和运算符。我们还将有两个条件。如果是左括号，我们应该压入栈；如果是右括号，我们可以继续弹出并追加。假设这个函数是左括号，我们将检查一个字符是否是左括号。

事实上，在这里检查当前标记是否为开头时，我们也应该使用这个函数，因为它可能是开大括号或开括号。这个函数会负责处理。可以说这个函数会搞定。同样地，对于最后一个else if，我们应该使用这个函数来判断是否为闭括号。好了，现在逻辑一致了。在这个while循环之后的最后一个else if里，我们应该额外执行一次pop操作，这次额外的pop会弹出开括号。现在我们完成了这个else if，这也是我的for循环的结束部分。其余部分保持不变。

在for循环之后，我们可以弹出剩余部分并附加到字符串中，最后返回结果。这就是我最终的伪代码。你可以查看本视频描述中的链接，获取实际实现的源代码。好的，我就讲到这里。本节课的内容就这些。感谢观看。

## 22、队列

大家好。我们已经讨论了一段时间的数据结构。众所周知，数据结构是计算机中存储和组织数据的方式。在本系列中，我们已经讨论了数组、链表等数据结构，并在最近几节课中讲解了栈的概念。本节课我们将向大家介绍队列。我们会像讲解栈时那样，先讨论队列的抽象数据类型（ADT）。我们知道，当我们将某个数据结构视为抽象数据类型时，只定义该数据结构可用的功能或操作，而不涉及具体实现细节。

我们将在后续课程中探讨具体的实现方法。本节课我们仅讨论队列数据结构的逻辑概念。好的，现在开始讲解。队列数据结构正如其名，与我们日常生活中排队的含义完全一致。队列是一种先进先出的结构，简称为 FIFO 结构。之前我们学习过栈结构，它是一种后进先出的结构，简称 LIFO。栈是一种集合数据结构，其插入和删除操作都发生在同一端，我们称之为栈顶。而队列则不同，插入操作必须发生在称为队尾的一端，删除操作则必须发生在另一端，我们称之为队头。

如果要从形式上把队列定义为一个抽象数据类型，那么队列就是一种具有限制条件的列表或集合：插入操作只能且必须在称为队尾的一端进行，而删除操作则只能在称为队头或队首的另一端执行。现在我们来定义队列支持的接口或操作。与栈类似，队列也有两个基本操作：插入操作称为入队（enqueue），也有人喜欢称之为压入（push）。入队操作应在队列的尾部插入一个元素。

删除操作被称为出队操作。在某些实现中，人们也把这个操作称为弹出。在栈的上下文中，压入和弹出更为人熟知。而在队列的上下文中，入队和出队更为常见。在实现时，你可以在接口中选择使用这些名称中的任何一个。出队操作应该从队列的前端或头部移除一个元素，并且通常还会返回这个从头部移除的元素。对于一个整数队列来说，入队和出队的函数签名可以像这样。

这里的入队操作返回void，而出队操作返回一个整数。这个整数应该是从队列中移除的元素。你也可以将出队操作设计为返回void。通常我们会保留第三个操作front或peak，仅用于查看队列头部的元素，就像我们在栈中保留的top操作一样。这个操作应该只返回前端的元素，而不删除任何内容。好的，我们还可以增加一些操作。我们可以有一个操作来检查队列是否为空。如果队列的大小有限制，那么我们还可以有一个操作来检查队列是否已满。

我之所以要指出这些操作的不同名称，也是因为大多数时候我们并不需要自己实现数据结构。我们使用语言库中内置的实现。不同语言库的接口可能有所不同。例如，如果你使用C++内置的队列，插入的函数是push，而在C#中则是enqueue。所以我们不应该混淆。我就把更知名的名字放在这里。好的，这些是我为队列ADT定义的操作：入队（enqueue）、出队（dequeue）、查看队首（front）和判空（isEmpty）。我们可以通过入队和出队操作每次在队列中插入或移除一个元素，查看队首仅用于观察头部元素，判空则用于验证队列是否为空。我在这里写的所有这些操作都必须以恒定时间完成，换句话说，它们的时间复杂度应该是O(1)。从逻辑上讲，队列可以表示为一个两端开放的图形或容器。

因此，元素可以从一端插入（入队），而从另一端移除（出队）。如果你还记得栈的话，我们曾将栈描述为一个仅一端开放的容器。在栈的语境中，插入（我们称之为压入）和移除（弹出）都必须发生在同一端；而在队列中，插入和移除应当发生在不同的两端。假设我想创建一个整数队列。初始时我们有一个空队列，我会先写下其中一个操作，然后在逻辑视图中向你展示模拟过程。假设我首先想将数字2入队。

我现在展示的这个图是一个空的整数队列。我正在这里执行一个入队操作。在程序中，我会调用一个入队函数，并将数字2作为参数传递给它。这次入队后，队列中就有了一个元素，即一个整数。因为目前队列中只有一个元素，所以队列的前端和后端是相同的。让我们再入队一个整数。现在我想插入数字5，5将被插入到队列的后端或尾部。让我们再入队一个。现在我想调用出队操作。

因此我们将从队列头部取出两个元素并将其移除。如果出队操作需要返回这个被移除的整数，那么我们将得到整数二作为返回值。入队和出队是队列的基本操作。在我们的设计中，为了方便起见还可以添加更多功能。比如这里我们提供了获取队首元素和判空功能——在当前阶段调用获取队首元素会返回数字五（整数五），但不会从队列中移除任何元素。此时调用判空函数会返回布尔值false，或者用0表示false，1表示true。以上就是队列的基本运作原理。

现在一个显而易见的问题是，在哪些实际场景中我们可以使用队列？队列数据结构有哪些应用案例？队列最常用于存在共享资源需要处理某些请求的场景中。但该资源一次只能处理一个请求，同一时间只能服务一个请求。在这种情况下，最合理的做法是将请求排队，先到的请求先得到服务。假设我们有一个网络共享的打印机，网络中的任何机器都可以向这台打印机发送打印请求。打印机一次只能处理一个请求，同一时间只能打印一份文件。因此，如果它在忙碌时收到请求，它不能直接说“我很忙，稍后再请求”，那样对打印机来说就太粗鲁了。实际上发生的是，管理打印机的程序会将打印请求放入一个队列中。

只要队列中有内容，打印机就会不断从队列前端取出请求并处理。你电脑上的处理器也是一种共享资源。许多正在运行的程序或进程都需要处理器的时间，但处理器一次只能处理一个进程。处理器就是那个必须执行所有指令、完成所有算术和逻辑运算的家伙。因此，这些进程会被放入队列中。队列通常可用于模拟多种场景中的权重。在后续课程中解决一些问题时，我们将详细讨论队列的这些应用。作为入门介绍，这部分内容已经足够。下节课我们将学习如何实现队列。本节课的内容就到这里。感谢观看。

在上节课中，我们向大家介绍了队列数据结构。我们讨论了队列作为一种抽象数据类型（ADT）。


## 23、用数组实现队列

众所周知，当我们把数据结构作为一种抽象数据类型来讨论时，我们将其定义为一种数学或逻辑模型。我们只定义数据结构可用的特性或操作，而不涉及实现细节。在本课中，我们将讨论队列的可能实现方式。

我将快速回顾一下我们目前讨论的内容。队列是一种具有特定限制的列表或集合，其约束条件为：插入操作只能在称为队列尾部的一端进行，而删除操作只能在称为队列头部的一端进行。在队列中，插入操作被称为入队操作，删除操作则被称为出队操作。

我已经在这里定义了队列的抽象数据类型（ADT），包含这四个操作。在实际实现中，所有这些操作都将是函数。Front操作应该简单地返回队列前端的元素，而不应该从队列中移除任何元素。isEmpty操作只需检查队列是否为空。所有这些操作必须在常数时间内完成，无论是出队操作还是查看前端元素，这些操作所花费的时间都不能依赖于变量，比如队列中元素的数量。换句话说，所有这些操作的时间复杂度都必须是O(1)。

好的，我们开始吧。队列是一种特殊的列表，其中的元素只能逐个插入或移除，且插入和移除操作分别在队列的两端进行。我们可以在队列的一端插入元素，在另一端移除元素，这与栈的操作方式类似。我们可以通过为列表添加这些约束或额外属性来实现队列。队列有两种常见的实现方式：一种是基于数组的实现，另一种是基于链表的实现。

让我们先讨论基于数组的实现。假设我们要创建一个整数队列。我们可以先创建一个整数数组。这里我创建了一个包含10个整数的数组，并将其命名为A。现在，我将使用这个数组来存储我的队列。我的做法是，在任何时刻，数组的一部分，从标记为front的索引开始，到标记为rear的索引结束，这部分就是我的队列。

在这个数组中，我将队列的前端显示在左侧，后端显示在右侧。在之前的例子中，我将前端显示在右侧，后端显示在左侧，这其实无关紧要。任何一边都可以作为前端，任何一边也可以作为后端。关键是要始终从后端添加元素，从前端移除元素。因此，在任何阶段，数组中从前端标记的索引到后端标记的索引之间的部分就是我的队列，数组中的其余位置则是可以用来扩展队列的空闲空间。

要将元素插入队列的末尾，我们可以增加尾部指针。因此，我们将在队列的尾部添加一个新的单元格，并在该单元格中写入新值。要插入的元素可以到达这个位置。我会在这些位置填入一些值。因此，队列中有这些整数，假设我们要插入数字5。为了插入，我们将增加尾部指针。当然，右侧应该有一个可用的单元格和一个空的单元格，现在我们可以在这里写入值5。

插入后，新的尾部索引是7，索引7处的值为5。现在执行出队操作意味着我们必须从队列的前端移除一个元素。在这个例子中，出队操作应该从队列中移除数字2。为了执行出队操作，我们可以简单地增加前端索引，因为在任何时候，只有从前端索引到尾部索引的单元格才是队列的一部分。通过增加前端索引，我已经将索引2从队列中移除，我们不需要关心不属于队列的单元格中存储的值。

当我们将一个单元格加入队列时，无论如何都会覆盖该单元格中的值。因此，对于出队操作来说，只需增加front就足够了。让我们快速为目前为止讨论的内容编写伪代码。在我的代码中，我将有两个变量，名为front和rear，最初我会将它们都设置为-1。假设对于一个空队列，front和rear都为-1。要检查队列是否为空，我们可以简单地检查front和rear的值，如果它们都为-1，我们就可以说队列为空。我刚刚在这里写了isEmpty函数。

-1 不是一个有效的索引。对于空队列来说，不存在队首和队尾。在我们的实现中，我们规定通过将队首和队尾都设为-1来表示队列的空状态。现在让我们来编写入队函数。入队函数将接收一个整数x作为参数。入队操作需要考虑几种情况。如果队尾已经等于数组A中的最大可用索引，我们就无法再插入或入队元素。在这种情况下，我们可以直接返回并退出。我更倾向于使用一个名为isFull的函数来判断队列是否已满。

如果队列已满，我们无能为力，只能直接退出。如果队列为空，我们可以向队列中添加一个单元格，即在索引0处添加单元格，并将rear索引处的值设为x。其他情况下，我们可以先递增rear，然后在rear索引处填入值x。我可以将这条语句“rear等于x”放在这两个条件语句之外，因为这对它们来说是通用的。

这就是我的入队函数。在我展示的这个示例数组中，让我们入队一些整数。我将调用入队函数，并在图中展示模拟过程。假设首先我想在队列中插入数字2。我调用入队函数，将数字2作为参数传入。队列是空的，所以我们将front和rear都设为0。现在我们将执行这条语句。我们将在索引0处写入值2。这就是执行一次入队操作后我的队列状态。

队列的前端和后端是相同的。让我们再调用一次入队操作。这次我想插入数字5。此时队列不为空，因此后端指针会递增。我们通过递增后端指针向队列添加了一个单元，现在将在新的后端索引处写入值5。让我们再入队一个数字。我已经将7入队。现在让我们编写出队操作。出队操作会有几种情况。如果队列已经为空，我们就无法移除元素。

在这种情况下，我们可以直接打印或抛出错误并返回或退出。还有一种特殊情况：如果队列中只有一个元素，此时 front 和 rear 不会等于 -1，而是彼此相等，因为我们在之前的 if 语句中已经通过 isEmpty 函数检查了 -1 的情况。在这个 else if 中，我们只需检查 front 是否等于 rear。如果满足条件，执行出队操作将使队列变为空，为了标记队列为空，我们需要将 front 和 rear 都设为 -1。

我们之前说过，表示空队列的方式是将 front 和 rear 都标记为 -1。在默认或正常情况下，我们只需递增 front 的值。在任何实现中，我们都必须特别注意边界情况，因为大多数错误都源于此。好了，这就是最终的出队函数。在这个例子中，假设当前阶段我们要执行出队操作。队列不为空，并且队列中不止一个元素，因此我们只需递增 front 的值。

在递增之前，我们可以将索引0处单元格的值设为任意内容，但已不属于队列的单元格中的值实际上无关紧要。在此阶段，除了队首和队尾之间的区段外，索引0、索引3或其他任何索引处的值都无关紧要。当我们向队列中添加单元格时，无论如何都会覆盖该单元格中的值。现在让我们执行更多的入队和出队操作。我将3入队，然后再将1入队。

每次入队时，我们都会增加rear的值。我刚才又进行了一些入队操作。现在让我们执行一次出队操作。如果我在这里再进行一次入队操作，rear将等于数组中可用的最大索引。让我们再入队一个元素。现在在这个阶段，我们无法再入队元素了，因为我们无法再增加rear的值。此时入队操作将会失败。现在有两个未使用的单元格，但根据我们编写的逻辑，我们无法使用位于front左侧的这两个单元格。

事实上，这是一个真实存在的问题，因为我们会不断出队。队首索引左侧的所有单元格将永远不会再被使用，它们只会被白白浪费。我们能否采取一些措施来利用这些单元格呢？其实，我们可以运用循环数组的概念。循环数组是一种我们在许多场景中都会用到的思路。这个想法非常简单：当我们遍历数组时，可以想象数组是没有尽头的。从0出发可以到达1，从1又可以到达2。

最后，当我们到达数组的最后一个索引时，就像这个例子中，当我们处于索引9时，下一个索引对我来说就是索引0。我们可以把数组想象成这样。记住，这只是看待数组的一种逻辑方式。在数组的循环解释中，如果我指向一个位置，当前的位置是i，那么下一个位置或下一个索引将不仅仅是i加1。它将是i加1对数组元素数量或数组大小取模。假设n是数组中的元素数量。

那么下一个位置将是i加1对n取模。取模运算可以得到除以n后的余数。对于除了n减1之外的任何i，这个取模运算不会有任何影响。但当i等于n减1时，下一个位置将是n对n取模，结果等于0。当你用一个数除以它自己时，余数为0。在数组的循环解释中，前一个位置将是i加n减1对n取模。为了确保括号内的表达式始终为正数，我们可以简单地说i减1对n取模。

我在这里加个n。仔细想想，你应该能明白为什么应该是i加n减1模n。现在有了这个数组的解释，只要数组中还有未使用的单元格，我们就可以在入队操作中增加rear。我现在要修改伪代码中的函数。Is empty保持不变。我们仍然认为对于一个空队列，front和rear会是-1。

让我们向下滚动，来到入队操作。在循环解释中，当rear的下一个位置（我们通过rear加1取模n来计算）等于front时，我将认为队列已满。这样就会出现这样的情况。目前，在循环解释中rear的下一个位置就是front。因此没有未使用的单元格，整个数组已经耗尽，在这种情况下不会发生任何变化。如果队列为空，我们可以简单地将front和rear设置为零。

在最后的else条件中，我们会这样递增rear指针：rear等于rear加1对n取模，其中n是数组中的元素数量。经过这样的修改，我的入队函数就完成了。现在让我们调用入队函数，向这个数组中插入一些内容。我想插入数字15。我们会进入最后的else条件。当前的rear指针是9。所以这个表达式将是9加1对n取模，这里的n是10，即数组a的大小为10，计算结果为零。现在我的新rear指针是0，我将在这里写入数字15。

现在来看看队列函数中需要做什么。前两个条件保持不变。如果队列已经是空的，或者队列中只有一个元素，我们将以同样的方式处理这些情况。在最后的else中，当我们要递增front时，需要以循环的方式递增。因此，我们将设置front等于front加1对n取模，其中n是数组中元素的总数，即数组的大小或数组中元素的总数。

现在我们来执行一个出队操作，此时front的值为2。因此计算方式为2加1再对10取模。这样我们又有一个新的单元格可用了。以上就是我们实现的核心部分。front操作非常简单，我们只需要返回front索引处的元素即可。同样地，这里我们也需要先检查队列是否为空，只有当front不等于-1时才返回front元素。我在这里写的所有这些操作、所有这些函数的时间复杂度都是常数级别的，即大O表示法中的O(1)。

我们在函数中进行简单的算术和赋值操作，并没有执行像运行循环这样的高成本操作。因此，所花费的时间不会取决于q的大小或其他变量。我就说到这里。将这个伪代码转换为你选择的语言中的可运行程序应该不会太难。如果你想看我的代码，可以查看这个视频描述中的链接。感谢观看。


## 24、用链表实现队列

在上节课中，我们看到了如何使用数组来实现队列。在本节课中，我们将学习如何用链表实现队列。正如我们之前讨论的，队列是一种先进先出的数据结构。队列数据结构是一种具有特定限制的列表或集合：插入操作只能在一端进行，而删除操作则在另一端进行。这些是我们通常为队列定义的基本操作：插入操作称为入队（enqueue），删除操作称为出队（dequeue）。

前端操作中，front函数应直接返回列表首元素，isEmpty函数则需检查队列是否为空。所有这些操作都必须保证恒定时间复杂度，即时间复杂度应为O(1)。当我们用数组实现队列时，采用了循环数组的概念来实现队列。

那么在这种情况下，我们有一个限制。这个限制就是数组的大小始终是固定的，一旦数组中的所有位置都被占满，即数组耗尽时，我们有两个选择：要么拒绝插入，即我们可以说队列已满，现在无法插入任何内容；要么我们可以创建一个更大的新数组，并将旧数组中的元素复制到新数组中，但这个过程会很耗费资源。如果我们使用链表来实现队列，就可以避免这个问题。

请注意，我这里展示的循环数组表示方法只是一种逻辑上的视角。我们也可以这样展示这个数组。正如我之前在数组实现中所说的，我们会遇到这个问题：如果数组填满了怎么办，我们需要处理这种情况。我们可以说队列已满，或者创建一个更大的新数组，并将之前填满的数组中的元素复制到这个更大的新数组中。此次复制操作所需的时间将与填充数组中的元素数量成正比，换句话说，我们可以认为该复制操作的时间复杂度为O(n)。数组实现还存在另一个问题：我们可能拥有一个足够大的数组，但队列可能并未使用其中的大部分空间。就像当前这个数组中，90%的内存都未被使用。

内存是一种重要资源，我们应始终避免不必要地占用内存。在现代机器中，少量未使用的内存并不会造成实质性问题。关键在于设计解决方案和算法时，我们需要分析并理解这些影响。现在让我们看看链表实现的效果如何。我在这里画了一个整数链表的逻辑视图。回到队列的基本定义，我们知道，队列是一种具有特定约束条件的列表或集合：元素必须始终从队列的一端（我们称之为队尾）插入，而元素必须始终从另一端（我们称之为队头）移除。强制将此属性应用于链表。链表，正如我们所知，是由称为节点的实体组成的集合，这些节点存储在内存中不连续的位置。每个节点包含两个字段：一个用于存储数据，另一个用于存储下一个节点的地址或对下一个节点的引用。

假设图中的节点地址分别为100、200和300。我也已经填写了地址字段。我们始终持有的链表标识是头节点的地址。我们通常将存储该地址的指针或引用变量命名为head。好了，现在我们说要用链表来实现队列。这些是我们定义队列时的典型操作。我们可以把链表当作队列来使用。我们可以选择链表的一端进行插入或入队操作。因此，链表中的节点必须始终从这一端插入。

另一端将用于出队操作。因此，如果我们选择头部进行入队操作，那么出队必须始终从尾部进行。如果我们选择尾部进行入队操作，那么出队必须始终从头部进行。无论我们选择哪一端进行操作，都必须满足一个关键要求：这些操作必须在恒定时间内完成，换句话说，它们的时间复杂度必须是大O(1)。正如我们之前课程所了解的，从头部进行插入或删除操作的成本是大O(1)，但从尾部进行插入或删除操作的成本则是大O(n)。

所以，情况是这样的。在链表的常规实现中，如果我们从一端插入元素，从另一端移除元素，那么根据我们选择哪一端进行操作，其中的入队或出队操作之一将耗费O(n)的时间复杂度。但我们的要求是这两个操作都必须以常数时间完成。因此，我们显然需要采取一些措施来确保入队和出队操作都能在常数时间内完成。

我们称这边为前端，这边为后端。因此，我希望从这一端入队节点，并从这一端出队。对于出队操作来说没有问题，因为从前端移除节点只需要常数时间。但插入或入队操作的时间复杂度会是O(n)。首先让我们看看为什么在尾部插入会比较耗时，然后或许我们可以尝试做些改进。要在后端插入，我们需要做的首先是创建一个节点。这里有一个新节点。

假设我有一个地址为350的节点，想要入队的整数是7。这个节点的地址部分可以设为null。现在我们需要做的是建立这个链接。我们需要将最后一个节点的地址部分设置为这个新创建节点的地址。为此，我们首先需要一个指针指向这个最后一个节点，存储该最后一个节点的地址。在链表中，我们始终持有的唯一标识是头节点的地址。要获取指向任何其他节点的指针，我们需要从头节点开始。

因此，我们首先创建一个指针temp，并将其初始设置为head。现在，我们可以通过一步操作将这个指针变量移动到它当前指向节点的下一个节点。我们使用类似"temp = temp.next"的语句来移动到下一个节点。在这个例子中，我们会从第一个节点移动到第二个节点，然后再从第二个节点移动到第三个节点。第三个节点是尾节点，现在我们可以利用这个临时指针temp来写入该节点的地址部分并建立这个链接。我们目前所做的从头部到尾部获取指针的整个遍历过程正是耗时所在。我们能做的是，可以避免这整个遍历过程。

我们可以有一个指针变量，就像 head 一样，它应该始终存储 rear 节点的地址。我可以将这个变量称为 tail 或 rear。让我们称它为 rear，并将存储 head 节点地址的变量称为 front。在任何插入或删除操作中，我们现在都必须同时更新前端和后端。但现在当我们进行入队操作时，假设我有一个地址为450的节点，我想将这个节点插入到后端。现在使用后指针，我们可以在这里更新地址字段。

因此，我们正在构建这个链接，现在可以更新后部。我们只需要修改一些地址字段，入队操作所需的时间将不再取决于链表中的节点数量。所以，通过这种设计，入队和出队操作都将是恒定时间操作。两者的时间复杂度都是O(1)。我们快速看看这个设计在C语言中的实际代码会是什么样子。我已经将节点声明为一个包含两个字段的结构体，一个用于存储数据，另一个用于存储下一个节点的地址。现在，我没有声明一个名为head的指针变量（即指向节点的head指针），而是声明了两个指针：一个名为front的节点指针和另一个名为rear的节点指针，并且最初我将它们都设置为null。假设我在全局作用域中定义了这两个变量。

因此，它们将对所有函数可用。我的入队函数将接收一个整数作为参数。在这个函数中，我将首先创建一个节点。我将使用C语言中的malloc或C++中的new操作符在所谓的动态内存中创建一个节点。我通过这个名为temp的节点指针变量指向新创建的节点。现在，在插入或入队操作中，我们可能会遇到两种情况。

如果队列中没有元素，即队列为空时，此时 front 和 rear 都将为 null。我们只需将 front 和 rear 都设置为 temp 所指向的这个新节点的地址，然后返回或退出。否则，由于我们已经有一个指向 rear 节点的指针，我们将首先设置当前 rear 的地址部分为这个新创建节点的地址，然后修改 rear 变量中的地址，使其指向这个新创建的节点。在撰写这些内容时，我假设你已经知道如何实现链表。如果你想复习一下相关概念，可以查看本系列之前的课程，或者查看本视频描述中提供的链接，那里有关于C或C++中链表实现的课程。如果我能通过模拟演示来展示运行过程，这段代码会更加清晰易懂。

假设最初我们有一个空队列。因此，front和rear都将是null。Null只是地址0的宏。在这个阶段，假设我们调用enqueue函数并传入数字2。现在，让我们逐步执行enqueue函数，看看会发生什么。首先，我们将创建一个节点。该节点的数据部分将被设置为2，地址部分最初将被设置为null。假设我们在地址100处获得了这个节点，其临时地址为temp。所以，一个名为temp的变量正在存储这个地址。这个变量指向这个节点。现在，front和rear都是null。

因此，我们将进入这个 if 条件语句，并简单地将 front 和 rear 都设为 100。当函数执行结束时，作为局部变量的 temp 将从内存中清除。在将 front 和 rear 都设置为这个新创建节点的地址后，我们将返回。那么，这就是第一次入队后队列的样子。假设此时我们再次调用入队函数，并将数字4作为参数传入。同样地，会创建一个新的节点。假设我得到了地址为200的新节点。这次队列不为空。因此，在这个函数中，我们首先会执行这条语句：rear.next = temp。

因此，我们将把这个节点的下一部分地址100设置为新创建节点的地址200。这样，我们就建立了这个链接。现在，我们将把新尾部节点的地址存储在这个名为rear的变量中。所以，这就是第二次入队后我的队列的样子。让我们再做一次入队操作。让我们将数字6入队。假设这次我们在地址300处得到了一个新节点。

所以，这就是我们的队列的样子。好的，现在我们来编写出队函数。在出队函数中，我会先创建一个临时节点指针，用来存储当前头节点或当前前端的地址。假设在这个例子中，此时我调用出队函数。出队操作也会出现几种情况。队列可能为空。以这个例子来说，在这个阶段，我调用了一个出队函数。在出队操作中，我们也会遇到几种情况。队列可能是空的。

因此，在这种情况下，我们可以打印一条错误信息并返回。如果队列为空，前端和后端都将等于null。我们只需检查其中一项即可确保无误。当前后节点相等时，我们将简单地将前后节点都设为null。在所有其他情况下，我们可以简单地让front指向下一个节点。因此，我们只需执行front等于front.next的操作。但为什么我们要使用这个临时指针指向节点？为什么我要在这段代码中声明这个临时指针指向节点呢？嗯，仅仅递增front是不够的。在这个例子中，当我调用dequeue时，我首先创建了temp。让我们一步一步地看看我目前所写的代码。

所以，在第一行，我创建了temp。然后因为队列不为空且队列中有多个元素，我将front设置为下一个节点的地址。这样，我的队列现在没问题了，所有的链接都得到了适当的修改。但之前位于前端的这个节点仍然在内存中。动态内存中的任何内容都必须显式释放。要释放这个节点，我们将使用 free 函数。对于这个 free 函数，我们应该传递节点的地址，这就是我们创建 temp 的原因。通过这个 free 操作，节点将从内存中彻底清除。以上就是入队和出队操作的实现。

如果你能看到，这些函数中有简单的语句。没有循环。因此，这些函数将花费恒定的时间。时间复杂度将是O(1)。在本课开始时，我们还讨论了数组实现的一些限制。比如数组填满和未使用内存的问题。在链表的实现中我们没有这些限制。

我们使用了一些额外的内存来存储下一个节点的地址。但除此之外，没有其他主要缺点。我就讲到这里。你可以自己编写其他函数，比如查看队列前端元素的front函数，或者检查队列是否为空的is_empty函数。如果你想获取我的源代码，可以查看本视频描述中的链接。感谢观看。

## 25、树

大家好。在本节课中，我们将向大家介绍一种有趣的数据结构，这种数据结构在计算机科学的许多场景中都有应用。这种数据结构就是树。在本系列中，我们已经讨论了所谓的线性数据结构。数组、链表、栈和队列，这些都是线性数据结构。它们本质上都是不同类型的数据集合，其中数据是按顺序排列的。

在我展示的所有这些结构中，都有一个逻辑上的起点和终点。这些集合中的任何元素都可以有一个下一个元素和一个前一个元素。因此，总的来说，我们拥有的是线性或顺序的排列。现在，正如我们所理解的，数据结构是计算机中存储和组织数据的方式。针对不同类型的数据，我们会使用不同的数据结构。我们选择哪种数据结构取决于多种因素。

首先，这取决于需要存储的内容。某种数据结构可能最适合特定类型的数据。其次，我们可能还需要考虑操作的成本。我们经常希望尽量减少最频繁执行的操作的成本。例如，假设我们有一个简单的列表，而大多数时候我们都在列表中搜索某个元素。那么，我们可能希望将列表或集合以排序后的数组形式存储。所以，我们可以非常快速地进行类似二分查找的操作。另一个因素可能是内存消耗。有时我们可能希望尽量减少内存使用。

最后，我们也可能为了便于实现而选择某种数据结构，尽管这可能不是最佳策略。树是一种常用于表示层次结构的数据结构。例如，假设我们想要展示一个组织中的员工及其在组织层级中的职位。那么我们可以这样展示。假设这是某家公司的组织层级结构。在这家公司，约翰担任首席执行官，他有两名直接下属，史蒂夫和拉玛。史蒂夫又有三名直接下属，分别是李、鲍勃和埃拉，史蒂夫是他们的经理。他们可能有一些头衔。拉玛也有两个直接下属。然后鲍勃有两个直接下属，汤姆有一个直接下属。

我在这里画的这个特定逻辑结构是一棵树。你得把这个结构倒过来看，它才会像一棵真正的树。这里的根在顶部，我们向下分支。树数据结构的逻辑表示总是这样，根在顶部，向下分支。好的，所以树是一种高效的方式来存储和组织自然具有层次结构的数据。但这并不是树在计算机科学中的唯一应用。

我们将讨论其他应用和一些实现细节，比如如何在计算机内存中创建这样的逻辑结构。首先，我想将树定义为一种逻辑模型。树数据结构可以定义为一组称为节点的实体，这些节点通过链接在一起模拟层次结构。树是一种非线性数据结构，它是一种层次结构。树中最顶层的节点称为树的根节点。

每个节点将包含一些数据，这些数据可以是任何类型。在我在这里展示的树中，数据是员工的姓名和职位。因此，我们可以有一个包含两个字符串字段的对象，一个用于存储姓名，另一个用于存储职位。好的，所以每个节点将包含一些数据，并且可能包含指向其他节点的链接或引用，这些节点可以称为其子节点。

现在，我要向你们介绍一些用于树形数据结构的词汇。在这里，我会给左边树上的节点编号，这样我就可以用这些数字来指代这些节点。我给这些节点编号只是为了方便自己，并不表示任何顺序。好的，回到正题，正如我之前所说，每个节点都会有一些数据。

我们可以在这些圆圈中填入一些数据。这些数据可以是任何类型的。它可以是一个整数、一个字符、一个字符串，或者我们可以简单地假设这些节点中已经填入了一些数据，只是我们没有显示出来。好的，正如我们刚才讨论的，一个节点可能包含指向其他节点的链接或引用，这些被指向的节点称为其子节点。这个结构中的每个箭头都代表一个链接。现在您可以看到，这个被我标记为1的根节点——再次强调，这个编号并不代表任何顺序关系。

我也可以将根节点称为节点10。因此，根节点与这两个节点（编号2和3）相连。所以，2和3将被称为1的子节点，而节点1将被称为节点2和3的父节点。我会写下所有这些术语。我们提到了根节点、子节点和父节点。在这棵树中，1是2和3的父节点。2是1的子节点，现在4、5和6是2的子节点。因此，节点2是节点1的子节点，但又是节点4、5和6的父节点。同一父节点的子节点称为兄弟节点。我在这里用相同的颜色表示兄弟节点。2和3是兄弟节点，4、5和6是兄弟节点，7和8是兄弟节点，最后9和10也是兄弟节点。

希望你现在已经清楚这些术语了。树中最顶层的节点称为根节点。根节点是唯一没有父节点的节点，如果一个节点直接连接到另一个节点，那么这两个节点之间就存在父子关系。树中没有子节点的任何节点称为叶节点。这里所有标黑的节点都是叶子。因此，叶子是另一个术语。所有至少有一个子节点的其他节点都可以称为内部节点。我们还可以定义更多关系，比如父节点的父节点可以称为祖父节点。因此，1是4的祖父节点，4是1的孙节点。一般来说，如果我们能够通过链接从节点A走到节点B（注意这些链接不是双向的），那么......

我们有一个从1到2的链接。因此，我们可以从1到2，但不能从2到1。当我们遍历树时，只能沿着一个方向前进。好的，所以如果我们能从节点A到节点B，那么A可以称为B的祖先，B可以称为A的后代。让我们以节点10为例。1、2和5都是10的祖先，而10是所有这些节点的后代。

我们可以从这些节点中的任何一个走到10。好的，现在让我问你几个问题，以确保你理解了这些内容。4和9的共同祖先是什么？4的祖先是1和2，9的祖先是1、2和5。所以，共同祖先是1和2。好的，下一个问题。6和7是兄弟姐妹吗？兄弟姐妹必须有相同的父母。6和7没有相同的父母。他们有相同的祖父母。1是两者的祖父节点。没有相同父节点但有相同祖父节点的节点可以称为堂兄弟节点。因此，6和7是堂兄弟节点，这些关系非常有趣。

我们也可以说3号节点是6号节点的叔叔，因为它是2号节点的兄弟节点，而2号节点是6号节点的父亲，或者我应该说是6号节点的父节点。所以，在树的词汇中我们有很多术语。好了，现在我要谈谈树的一些特性。树可以被称为递归数据结构。我们可以递归地将树定义为一个结构，它由一个称为根的特定节点和一些子树组成，其排列方式是树的根包含指向所有子树根的链接。图中的T1、T2和T3就是子树。在我左边画的这棵树中，根节点有两个子树。

我将根节点显示为红色，左子树为棕色，右子树为黄色。我们可以进一步拆分左子树，将节点2视为该子树的根，这个以节点2为根的特定树有三个子树。我用三种不同的颜色显示这三个子树。递归本质上是以一种自我相似的方式简化事物。树的这种递归特性在所有实现和应用中无处不在。接下来我想讨论的性质是，在一棵有n个节点的树中，恰好会有n-1条链接或边。

图中的每个箭头都可以称为链接或边。除根节点外，所有节点都恰好有一条入边。如你所见，我将选择这个编号为2的节点。它只有一条入链接。这是入站链接，而这三个是出站链接。每个父子关系都会有一条链接。因此，在一个有效的树结构中，如果有n个节点，就会有恰好n-1条边。除根节点外，每个节点都有一个入边。好的，现在我想谈谈这两个属性：深度和高度。树中某个节点x的深度可以定义为从根节点到节点x的路径长度。路径中的每条边都会为长度贡献一个单位。

因此，我们也可以说这是从根节点到x的路径中的边数。根节点的深度为0。让我们选择其他节点。对于编号为5的这个节点，从根节点到它的路径中有两条边。因此，这个节点的深度是2。在这棵树中，节点2和3的深度为1，节点4、5、6、7和8的深度为2，节点9、10和11的深度为3。好，现在树中一个节点的高度可以定义为从该节点到叶子节点的最长路径中的边数。

因此，某个节点x的高度等于从x到叶子节点的最长路径上的边数。在这张图中，对于节点3来说，从该节点到任意叶子节点的最长路径是2。所以，节点3的高度是2。节点8也是一个叶子节点。我会在这里标记所有的叶子节点。叶子节点是指没有子节点的节点。从节点3到任意叶子节点的最长路径是2。因此，节点3的高度是2。叶子节点的高度为0。那么，这棵树中根节点的高度是多少呢？我们可以从根节点到达所有的叶子节点。最长路径上的边数是3。因此，这里的根节点高度是3。我们还定义了树的高度。

树的高度定义为根节点的高度。我这里展示的这棵树的高度是3。高度和深度是不同的属性，一个节点的高度和深度可能相同也可能不同。我们经常混淆这两者。根据属性，树被分为不同的类别。在不同的场景中会使用不同种类的树。最简单且最常见的树类型具有这样的特性：任何节点最多可以有两个子节点。

在该图中，节点2有3个子节点。我将移除一些节点，现在它变成了一棵二叉树。二叉树是最著名的，在本系列中，我们将主要讨论二叉树。实现树的最常见方式是动态创建节点，并使用指针或引用将它们连接起来，就像我们处理链表那样。我们可以这样来看待树的结构。在我右边绘制的这个结构中，节点包含3个字段。其中一个字段用于存储数据。假设中间单元格存储数据，左侧单元格存储左子节点的地址，右侧单元格存储右子节点的地址。

其中一个字段用于存储数据。假设中间单元格存储数据，左侧单元格存储左子节点的地址，右侧单元格存储右子节点的地址。因为这是一棵二叉树，我们最多只能有两个子节点。我们可以将其中一个子节点称为左子节点，另一个称为右子节点。在C或C++编程中，我们可以像这样定义一个节点结构。我们这里有3个字段。一个用于存储数据。假设数据类型是整数。我已经在这些节点中填写了一些数据。因此，每个节点包含3个字段：一个用于存储数据的整型变量，以及两个指向节点的指针。

一个用于存储左子节点的地址，该左子节点将成为左子树的根；另一个用于存储右子节点的地址。我们只保留了两个指针，因为在二叉树中最多只能有两个子节点。这个特定的节点定义仅适用于二叉树。对于可以有任意数量子节点的通用树结构，我们会采用其他数据结构，后续课程将详细讲解。事实上，我们会在之后的课程中深入讨论具体实现方式。这里只是让大家对实现方式有个初步概念。好了，这部分内容很棒。我们现在理解了什么是树形数据结构。但在一开始我们说过，存储天然具有层级关系的数据并非树的唯一用途。

那么，让我们快速看一下树在计算机科学中的一些应用。第一个应用当然是存储自然分层的数据。例如，磁盘驱动器上的文件系统，文件和文件夹的层次结构就是自然分层的数据。它以树的形式存储。下一个应用是组织数据，组织集合以便快速搜索、插入和删除。例如，我们将在接下来的几节课中详细讨论的二叉搜索树，可以在其中以对数时间（log n）的复杂度搜索元素。一种称为字典树的特殊树被用来存储字典。它非常快速高效，常用于动态拼写检查。树数据结构也用于网络路由算法。这个列表还有很多。我们将在后面的课程中讨论不同种类的树及其应用。现在我就讲到这里，作为入门介绍已经足够了。接下来的几节课，我们将讨论二叉搜索树及其实现。本节课就到这里。感谢观看。

