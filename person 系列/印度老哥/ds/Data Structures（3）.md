
## 十一、递归法反转链表

在之前的课程中，我们学习了如何用递归遍历链表。我们编写了代码，用递归方式正向和反向打印链表的元素。实际上我们并没有反转链表，只是按逆序打印了元素。在这节课中，我们将使用递归来反转链表。这是另一个著名的编程面试题。如果我们有一个像这样的输入链表，这里有一个整数链表。

链表中有四个节点。这里的每个矩形块代表一个节点，分为两部分：第一部分用于存储数据，第二部分用于存储下一个节点的地址。当然，我们还会有一个变量来存储第一个节点（即头节点）的地址，这个变量我命名为 head，当然你也可以随意命名，我习惯称它为 head。

这是我们的输入列表。反转后，输出应该像这样。这个变量 head 应该存储原始列表中最后一个节点的地址。原始列表中的最后一个节点位于地址 250。然后我们会从 250 到 150，150 到 200，200 到 102。Null 其实就是地址零。

在之前的课程中，我们已经学习了如何用迭代方法反转链表。现在，让我们来看看如何用递归来解决这个问题。在我们的解决方案中，必须通过反转链接来调整链表，而不是通过移动数据或其他方式。那么让我们首先理解可以在递归方法中使用的逻辑。如果你还记得我们之前的课程，在那里我们使用递归来反向打印列表，即按相反顺序打印元素，那么递归为我们提供了一种在 C 或 C++ 程序中以编程方式向后遍历列表的方法，节点将是这样的结构。

因此，让我们首先看一下之前课程中的函数，即用于反向打印列表的递归函数，我们向这个函数传递一个节点的地址，最初我们传递的是头节点的地址。我们有一个退出条件，如果传入的地址为空，则直接返回；否则进行递归调用并传入下一个节点的地址。主方法通常会调用 reverse print 并传入头节点的地址。然后这个函数会先进行递归调用。然后当这个递归调用完成时，才会打印。所以我用 RP 作为 reverse print 的缩写。递归会像这样继续下去。

当它到达这个特定的调用时，如果参数为 null，就会返回。因此这个调用会结束，控制权会再次回到这个调用，参数是地址 250。现在我们正在打印地址 250 处节点的值，这个值将是 4。然后这个人完成了。接着我们继续打印 5。同样地，我们接着打印 6 和 2。

递归为我们提供了一种先正向遍历列表，再反向遍历列表的方法。现在让我们看看如何利用递归实现反转功能。为了简化和实现方便，假设 head 是一个全局变量。因此，所有功能都可以访问。现在我们将实现一个名为 reverse 的函数，该函数将接收一个节点的地址作为参数。最初，我们将把头节点的地址传递给这个函数。

现在我想在我的递归中做类似的事情，我想一直走到最后，我想一直进行递归调用，直到我到达最后一个节点。对于最后一个节点，链接部分将为 null。所以这是我退出递归的条件。这个退出条件将阻止我们在递归中无限进行下去。我在这里做的事情非常简单。一旦到达最后一个节点，我就会修改头指针，让它指向这个节点。所以递归会这样工作：从主方法中，我们将调用反转函数，并传入头节点的地址（地址 100）。

我们会来检查这个条件：如果 p.next 等于 null，不，对于地址为 100 的节点来说，它等于 200。因此，这个递归会一直进行，直到我们到达这个调用，即传递地址 250 给 reverse 函数的调用。然后我们会往下走，现在我们已经到达了这个退出条件，此时 head 将被设置为 P，链表将会变成这样。现在，reverse 250 的调用将结束，我们将返回到 reverse 150。在这个递归调用 reverse 函数之后，这里没有任何语句；如果这里有其他语句，那么在我们从 reverse 250 返回后，它们现在就会为 reverse 150 执行。这就是我们实际上如何以逆序遍历列表的方式。

如果你看到当反转 250 完成后，节点直到 250 已经被反转，因为头节点指向这个节点，并且这个节点的链接部分被设置为 null。所以直到 250 我们已经完成了反转。现在当我们来到 150 时，我们可以确保在完成反转 150 的执行后，列表直到 150 已经被反转。要实现这样的写法，我们需要做两件事：首先必须切断这个节点，并让这个指针指向另一个指针。因此我们要建立这个链接，同时必须切断原有链接，让这个指针指向空值。这样当我们完成这次调用后，地址150之前的节点就会被反转。

所以我在函数中写了这三行代码，它们会在递归调用之后执行。也就是说，它们会在递归展开时执行，此时我们正以相反的方向遍历列表。因此，当我们执行 reverse 150 并在递归后返回到这里时，我们就处在这一特定的代码行。

```c
if(p->next == NULL){
	head = p;
	return;
}
struct Node* q = p->next;
q->next = p;                   // 两句合并为一句  p->next->next = p;
p->next = NULL;
```

所以 P 会是 150，而 q 会是 p 的下一个。因此 q 会是250。这个家伙是 P，P，而这个家伙是 q。我们正在说设置 q->next=p。所以我们会将这个特定的字段设置为 100。所以我们正在建立这个链接并切断这个链接。现在我们可以看到将 p.next 设为 null。因此，我们正在构建这个链接，使 p.next 为 null，现在对 reverse 150 的调用完成了。当这次调用完成后，列表直到 150 的部分会被反转。如你所见，头部是 250。所以从 250 开始，我们将前往 150，然后从 150 我们将前往null。

所以在 150 之前，我们有一个反转后的列表。这就是当对 200 的反转调用完成时的情况，直到 200 为止，我们有一个反转后的列表。然后，我们再次回到对 100 的反转执行。而当 reverse 100 函数执行完毕并返回到主函数时，最终的内存状态就会呈现如此模样。我们在前一课中已经了解到递归执行时内存中的运作机制。在递归过程中，所有函数调用的执行状态都被保存在内存的栈区。在这个函数中，我们基本上就是在递归过程中将节点的地址存储在一个结构中。然后我们首先处理最后一个节点，使其成为反转链表的一部分。接着我们再次回到前一个节点，并不断重复这个过程。

观看上一课，详细了解递归在内存中如何运作的模拟过程。这里还有几点需要注意。其中一点是，与其写这两行代码，我可以将它们合并为一行，比如写成 P->next->next = P，这样表达的意思是一样的，只不过这种写法更加晦涩难懂。

还有一点我们假设的是 head 是一个全局变量。如果 head 不是全局变量，这个反转函数就需要返回修改后的 head 的地址。我把这个留作练习给你们去做。以上就是使用递归反转链表的方法。感谢观看。

## 十二、双向链表

大家好。在本系列课程中，我们已经对链表进行了较多讨论，了解了如何创建链表以及如何对链表执行各种操作。正如我们所知，链表是由称为节点的实体组成的集合。到目前为止，在我们所有的实现中，创建的链表每个节点都包含两个字段：一个用于存储数据，另一个用于存储下一个节点的地址。假设我们这里有一个整数链表。

所以我会在每个节点的数据字段中填入一些值。假设这些节点的地址分别是 200、250 和 350。我还会在每个节点中填入地址字段，第一个节点的地址字段将是第二个节点的地址，也就是 250。第二个节点中的地址字段将是第三个节点的地址，即 350。而第三个节点中的地址部分将为零或空。我们始终保留的链表的标识是头节点的地址或对头节点的引用。

假设我们有一个名为 head 的变量，仅用于存储头节点的地址。请记住，这个名为 head 的变量只是一个指向头节点的指针。理想情况下，我们应该将其命名为类似 head pointer 的名称，它只是指向头节点，而不是头节点本身。头节点就是这个家伙，链表中的第一个节点。好的，现在在我们展示的这个链表中，每个节点只有一个链接，即指向下一个节点的链接。在实际程序中，我在这里展示的链表节点将这样定义。

到目前为止，我们在所有课程中都是这样定义节点的：这里有两个字段，一个是整数类型用于存储数据，另一个是指向节点结构体的指针类型（struct node*）。我将这个字段命名为next。当我们默认说链表时，指的是这种我们也可以称之为单链表的列表。我们这里有一个单向链表。

本节课要讨论的是双向链表的概念。双向链表的原理其实很简单。在双向链表中，每个节点会有两个链接，一个指向下一个节点，另一个指向前一个节点。在编程实现上，这是我们在 C 或 C++ 中为双向链表定义节点的方式。我这里还有一个字段，它同样是一个指向节点的指针，这样我就可以存储一个节点的地址，通过这个字段我可以指向一个节点。

这个字段将用于存储前一个节点的地址。在逻辑表示中，我会这样绘制我的节点。现在，我有一个字段用于存储数据，一个用于存储前一个节点的地址，还有一个用于存储下一个节点的地址。假设我想创建一个整数的双向链表。我在这里创建了三个节点，假设这些节点的地址分别是 400、600 和 800。我会填充一些数据，假设每个节点中间的单元格用于存储数据。

最右边的单元格，假设是用来存储下一个节点的地址。因此，对于第一个节点，这个字段将是 600，这意味着我们有一个这样的链接。对于第二个节点，这个字段将是 800。对于第三个节点，此字段将为零。对于第一个节点，没有前一个节点。因此，这个最左边的单元格（本应包含前一个节点的地址）将为零或空。

第二个节点的前一个节点将是 400。第三个节点的前一个节点是地址为 600 的节点。当然，我们还会有一个变量来存储头节点的地址。好的，现在我们有一个包含三个节点的整数双向链表。既然已经了解了双向链表的基本概念，如果你之前实现过单向链表，那么实现双向链表应该不会太难。

一个显而易见的问题是，我们为什么需要创建一个双向链表？双向链表有哪些优势或重要应用场景？首先，其优势在于，现在我们如果有一个指向任意节点的指针，就可以进行正向和反向的查找。仅凭一个指针，我们就能访问当前节点、下一个节点以及前一个节点。我这里展示了一个名为temp的指针。如果temp是指向某个节点的指针，那么temp.next就是指向下一个节点的指针，即下一个节点的地址；而temp.previous，更准确地说，temp->previous，实际上是(\*temp).prev的语法糖。

所以，这个 temp->prev 指的是前一个节点，或者简单来说就是指向前面节点的指针。在这个例子中，temp 当前存储的值是 600，temp.next 是 800，而 temp.prev 是 400。在单链表中，你无法仅通过一个指针来查看前一个节点，必须额外使用一个指针来跟踪前一个节点。

在很多情况下，能够查看前一个节点会让我们的工作变得更轻松。甚至某些操作（比如删除）的实现也会变得简单许多。在单链表中要删除一个节点，你需要两个指针：一个指向要删除的节点，另一个指向前一个节点。但在双向链表中，我们只需使用一个指针（指向待删除节点的指针）就能完成这一操作。总而言之，这种能在链表中进行反向查找的能力非常实用，它让我们能够双向遍历链表。

双向链表的缺点是需要为指向前一个节点的指针使用额外的内存。以一个整数链表为例，假设在典型的架构中整数占四个字节，指针变量也占四个字节，那么在单链表中，每个节点将占用八个字节，其中四个字节用于数据，四个字节用于指向下一个节点的链接。而在双向链表中，每个节点将占用十二个字节，其中四个字节用于数据，八个字节用于链接（指向前后节点的指针）。

对于整数链表，链接所占用的空间将是数据的两倍。使用双向链表时，在插入或删除时需要更小心地重置链接，比单向链表需要重置更多的链接。因此我们更容易出错，我们将在下一课的 C 程序中实现双向链表，编写遍历、插入和删除等基本操作。这节课就到这里。感谢观看。

## 十三、C/C++ 实现双向链表

在上一课中，我们了解了什么是双向链表。在本节课中，我们将用 C 语言实现双向链表，编写插入、遍历和删除等简单操作。正如上节课所讲，双向链表的每个节点包含三个字段——我已在此绘制了双向链表的逻辑示意图：一个字段存储数据，一个存储下一节点地址，另一个存储前一节点地址。在 C 或 C++ 程序中，整型链表的节点定义将采用这种形式。

在逻辑表示中，我会在每个节点中填入一些数据。假设这些节点的地址分别是 400、600 和 800。我也会填入 next 和 prev 字段。此外，我们还需要一个指向头节点的指针变量。通常我们将这个指针变量命名为 head。在我的实现中，我会编写这些函数：一个用于在链表开头（即头部）插入节点的函数，该函数将接收一个整数作为参数；另一个用于在链表尾部插入节点的函数；以及一个在从头到尾遍历链表时打印链表元素的函数。

我将再写一个函数，在从尾到头遍历链表时逆序打印元素。这个反向打印函数会验证每个节点的反向链接是否正确创建。现在让我们在一个实际的 C 程序中编写这些函数。在我的 C 程序中，我将节点定义为一个包含三个字段的结构体。第一个字段是整型，用于存储数据。第二个字段是指向节点的指针类型，用于存储下一个节点的引用。


And the third field is a pointer to node to store the reference of previous node. I have defined a variable named head which once again is a pointer to node. And I have defined this variable in

ds-5