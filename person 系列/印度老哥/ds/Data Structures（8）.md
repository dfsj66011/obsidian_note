
## 37、二叉搜索树中的中序后继节点

在本节课中，我们将解决二叉搜索树上的另一个有趣问题：给定二叉搜索树中的一个节点，我们需要找到它的中序后继节点，即在二叉搜索树的中序遍历中紧接在该节点之后的节点。众所周知，在二叉树的中序遍历中，我们首先访问左子树，然后访问根节点，最后访问右子树。左右子树均以相同方式递归遍历。

因此，对于每个节点，我们首先访问其左子树，然后访问节点本身，最后访问其右子树。在本系列的前一节课中，我们已经详细讨论了中序遍历。你可以查看本视频的描述以获取相关链接。中序遍历的实现基本上是一个递归函数，类似于我在这里展示的内容。这个函数中有两个递归调用，一个用于访问左子树，另一个用于访问右子树。中序遍历的时间复杂度为O(n)，其中n是树中的节点数量。

我们访问每个节点恰好一次，因此所花费的时间与树中的节点数量成正比。我在这里画了一个整数的二叉搜索树。众所周知，二叉搜索树是一种二叉树，其中对于每个节点，左侧节点的值较小，右侧节点的值较大。让我们快速看看这个二叉搜索树的中序遍历会是什么样子。我们将从树的根节点开始。对于任何节点，我们首先需要访问其左侧的所有节点，然后才能访问该节点本身。

所以我们必须向左走。基本上，我们会递归调用以访问这个节点的左子节点。对于这个节点，我们再次发现左边有东西。因此，我们会进行另一个递归调用并访问它的左子节点。现在我们到达值为8的这个节点，我们需要再向左走一次。现在对于值为6的这个节点，它是一个叶子节点，左边没有任何东西。所以我们可以简单地认为它的左子树已经完成，因此我们可以访问这个节点。对我来说，访问就是读取该节点中的数据。我会在这里写下数据。

ancestor
successor

现在对于这个节点来说，右边也没有任何东西了。所以我们可以简单地认为它的右边也处理完了。现在这个节点已经完全处理完毕。因此，这个节点对应的递归调用将结束，我们将返回到其父节点对应的调用。如果我们从一个节点的左子节点返回，那么这个节点将是未被访问的状态。因为只有在其左子树处理完成后，我们才能访问该节点。所以当我们返回到8时，8是未被访问的状态。

因此，我们可以直接访问这个节点，也就是读取该节点中的数据。当我访问一个节点时，我会将其标记为黄色。现在这个节点的右侧没有任何内容，所以我们可以直接认为右侧已完成。现在我们已完成对该节点的处理，因此与该节点对应的调用将结束，我们将返回到其父节点。再次，我们从左侧返回到父节点。此时，父节点（即值为10的这个节点）尚未被访问。

如果我们从右侧返回一个节点，那么它已经被访问过了。现在我正在访问10，现在我们可以去10的右侧。到目前为止，我们已经访问了三个节点。我们首先访问了值为6的节点，然后访问了值为8的节点。所以8是6的后继节点，然后10是8的后继节点。现在让我们看看10的后继节点会是什么。对于值为6和8的节点，右侧没有任何东西。所以我们正在回溯并转到父节点。但是对于一个节点，如果右侧有东西，也就是说如果有一个右子树，那么它的后继节点肯定会在它的右子树中。

因为在访问那个节点后，我们将向右移动。现在在这个阶段，我们处于值为12的节点。对于这个节点，我们首先会向左移动，现在处于值为11的节点，这是一个叶子节点。左边没有内容。所以我们可以简单地说左边已经完成，可以打印数据了。也就是说访问这个节点。因此，10的有序后继是11。现在对于值为11的节点，右边没有内容。所以我们将回到它的父节点，现在可以访问这个节点了。所以在11之后，我们有12。12的右边没有内容。所以对这个节点的调用将结束，我们将回到它的父节点。现在我们又回到了10。

但这次是从右边来的。所以这个节点已经被访问过了。所以我们不需要做任何操作，可以直接去它的父节点。现在我们来到了值为15的这个节点。我们是从左边过来的。这个节点还没被访问过。所以我们可以访问它。然后我们可以去它的右边。我们会继续这样下去。15的后继节点会是16。在16之后我们会打印17。然后在17之后我们会打印20。接着是25。最后一个元素会是27。这就是这个二叉搜索树的中序遍历。注意到我们打印出来的数字是按顺序排列的。

当我们对二叉搜索树进行中序遍历时，元素会按排序顺序被访问。现在我们要解决的问题是，给定树中的一个值，我们想找到它的中序后继节点。在二叉搜索树中，这将是树中下一个更高的值。但这有什么大不了的？难道我们不能直接进行中序遍历并在遍历过程中找出后继节点吗？当然可以这样做，但这样做的代价很高。中序遍历的时间复杂度是O(n)。

我们可能希望做得更好。在某些数据中查找下一个和上一个元素可能是一项频繁执行的操作。而二叉搜索树的优点在于，像插入、删除和搜索这样的频繁操作的时间复杂度为O(h)，其中h是树的高度。因此，如果我们能在O(h)的时间复杂度内找到后继和前驱节点，那将是非常好的。我们总是尽量保持树的平衡以最小化其高度。平衡二叉树的高度为以2为底的log n。而任何操作的O(log n)运行时间几乎是我们能获得的最佳运行时间。

那么我们能否在O(h)的时间复杂度内找到中序后继节点呢？我在这里重新绘制了示例树。让我们看看在不同情况下我们能做些什么。值为10的这个节点的后继节点会是哪个？我们能否通过逻辑推理得出答案？回想一下我们之前模拟的中序遍历过程，如果已经访问过当前节点，说明其左子树已经遍历完毕。此时我们已经读取了该节点的数据，接下来需要转向右子树。在右子树中，只要存在左子节点，我们就需要不断向左遍历。就像这个值为11的节点，当无法继续向左时（此处该节点没有左子节点），就到达了后继节点。

那么这就是我接下来要访问的节点。所以对于我们的节点来说，如果存在右子树，那么中序后继节点就是其右子树中最左边的节点。在二叉搜索树（BST）中，它将是右子树中值最小的节点。我称这种情况为第一种情况。在这种情况下，我们只需要在右子树中尽可能地向左走。在BST中，这也意味着寻找右子树中的最小值。最左边的节点同时也是子树中的最小值。这是一种情况。我们这里的节点有一个右子树。如果没有右子树，后继节点会是什么呢？

访问完值为8的节点后，我们该访问哪个节点？这个节点没有右子树。如果我们已经访问过这个节点，说明我们已访问过它的左子树和它本身。而右侧没有内容，因此可以认为右侧也已访问完毕。但我们还没找到后继节点。那么接下来该往哪里走？回想我们之前模拟的过程，这时需要回溯到这个节点的父节点。如果是从左侧回溯到父节点（当前就是这种情况），那么这个父节点应该尚未被访问过。

对于这个值为10的节点，我们刚刚完成了它的左子树遍历并返回。因此现在我们可以访问这个节点了。这就是我的后继节点。现在让我们选择另一个没有右子树的节点。对于这个值为12的节点，什么节点不会成为它的后继节点？接下来我们会访问哪个节点？这里再次说明，该节点没有右子树。所以我们必须回溯到它的父节点，看看它是否未被访问过。

但如果我们从右侧回溯到父节点，即当前刚访问的节点是右子节点（如本例所示），那么其父节点必然已被访问过——因为我们是在遍历完右子树后返回的。该父节点一定是在转向右子树前就被访问过了。此时我们该怎么做？

递归会继续回溯到10的父节点。现在我们从左侧抵达15。由于这个节点尚未被访问，因此可以访问它——这就是我们要找的后继节点。若目标节点没有右子树，则需要向上查找最近的祖先节点，且要求目标节点位于该祖先节点的左子树中。以节点12为例：我们先回溯到10。

但12位于10的右子树中。所以我们继续查找下一个祖先节点15。而12位于15的左侧。因此，15就是12在其左侧的最近祖先节点。于是，这就是我的中序后继节点。这个算法运行良好，但存在一个问题：我们如何从一个节点访问其父节点？其实，我们可以设计树的结构，使节点能够引用其父节点。到目前为止，在大多数课程中，我们将节点定义为包含三个字段的结构体，类似于这样。这就是我们在C或C++中定义节点的方式。

我们有一个字段用于存储数据，还有两个指向节点的指针用于存储左右子节点的引用或地址。通常，再增加一个字段来存储父节点的地址会非常有用。我们可以这样设计树结构，这样在利用父链接向上遍历树时就不会有问题。我们可以轻松地访问祖先节点。但如果没有指向父节点的链接呢？在这种情况下，我们可以从根节点开始，沿着树从根节点走到给定的节点。在二叉搜索树（BSD）中，这非常简单。对于12，我们将从根节点开始。12小于根节点的值。

所以我们需要向左走。现在我们到了10。因为12比10大，所以我们需要向右走。现在我们到了12。如果我们从根节点走到给定节点，就会经过该节点的所有祖先节点。中序后继节点就是这条路径上最深的那个节点或最深的祖先节点，且给定节点位于该节点的左子树中。12只有两个祖先节点。我们有10，但12位于10的右侧。然后我们有15，12位于15的左侧。所以15就是我的后继节点。

现在，我们使用这个方法来寻找6的后继节点。首先，我们将从根节点向下走到这个节点。6位于所有祖先节点的左侧。但对于6来说，最深的、6位于其左侧的祖先是值为8的这个节点。所以这就是我的后继节点。记住，我们只需要在没有右子树的情况下查看祖先节点。对于6来说，没有右子树。好的，这个算法看起来不错。现在让我们来编写代码。在我的C++代码中，我将编写一个名为get_successor的函数，它将接收根节点的地址和需要查找后继节点的另一个节点的地址。

这个函数将返回后继节点的地址。我们可以用不同的方式设计这个函数。不同于传入需要查找后继节点的指针作为参数，我们可以直接传入数据作为参数。对于这个数据元素，我们可以找到后继节点并返回其地址。因此这里的返回类型是结构体节点指针（struct node*），因为我们将在指针中返回地址。或者我们也可以直接返回元素本身，即后继元素本身。

我们可以使用其中任何一种签名来实现。让我们来实现这个。我们将传入当前节点的数据，并返回后继节点的地址。现在，我们需要做的第一件事是搜索包含此数据的节点。我将调用一个名为find的函数，该函数将接收根节点的地址和数据，并返回指向包含此数据的节点的指针。如果此函数返回null，即如果在树中未找到该数据，我们可以直接返回null。否则，我们在这个名为current的节点指针中拥有当前节点的地址。

在二叉搜索树（BSD）中，查找操作的时间复杂度为O(h)，其中h是树的高度。在BSD中进行查找并不算特别耗时。如果我们传递当前节点的地址而非数据作为第二个参数，本可以避免这次查找。不过暂且先这样处理。现在让我们来找出该节点的后继节点。如果该节点存在右子树（即右子树不为空），我们需要找到右子树中最左侧的节点。这里我声明了一个临时节点指针，初始时将其指向current.right。

使用这个while循环，我将到达最左侧的节点。只要左侧还有节点，就继续前进。最终，当我退出这个循环时，我将获得右子树中最左侧节点的地址，并可以返回这个地址。这个特定的节点也将是右子树中值最小的节点。我将把这段代码移到另一个函数中。我编写了一个名为findMin的函数，它将返回树或子树中值最小的节点。在getSuccessor函数中，我只需说return findMin，并传入当前节点右子节点的地址。

简单来说，我在这里传递的是右子树。好的，现在我们来讨论第二种情况。如果没有右子树，我们需要做的是从根节点遍历到当前节点，并找到最深的祖先节点，使得当前节点位于该祖先节点的左子树中。接下来，我要做的是声明一个名为successor的节点指针，初始时将其设为null。同时，我还会声明另一个名为ancestor的节点指针，初始时将其设为根节点。通过这个while循环，我们将遍历树直到到达当前节点。

要遍历这棵树，我们将利用二叉搜索树的性质：对于每个节点，左侧节点的值较小，右侧节点的值较大。如果当前节点的数据小于祖先节点的数据，那么这个祖先节点可能是当前节点的中序后继，因为当前节点位于其左侧。因此，我们可以将这个祖先节点设为后继节点，并在遍历过程中继续向左搜索。如果找到一个更深的节点，且当前节点位于其左子树中，那么后继节点将被更新。

否则，如果当前节点位于右侧，我们只需向右移动。当我们退出这个while循环时，后继节点要么为null，要么是某个节点的地址。并非树中的所有节点都有后继节点。具有最大值的节点不会有后继节点。退出这个while循环后，我们可以返回后继节点。所以，这就是我的getSuccessor函数，我认为它应该可以工作。你可以在本视频的描述中找到完整源代码的链接。总的来说，这个函数的时间复杂度将是O(H)。

而这正是我们想要的。我们希望在O(H)时间内找到后继节点。这里，我们已经在O(H)时间内进行搜索。寻找最小值同样需要O(H)时间，在二叉搜索树中从根节点走到某个节点也需要O(H)时间。因此，整体复杂度是O(H)。如果你理解了这个代码和逻辑，那么编写查找前驱节点的函数对你来说应该非常容易。我鼓励你动手写一写。今天就讲到这里。在接下来的课程中，我们将解决更多关于二叉树和二叉搜索树的有趣问题。感谢观看。



Hello everyone. So far in this series on data structures, we have talked about some of the linear data structures like array, linked list, stack, and queue. In all these structures, data is arranged in a linear or sequential manner.So we can call them linear data structures. And we've also talked about tree, which is a nonlinear data structure. Tree is a hierarchical structure.Now as we understand, data structures are ways to store and organize data. And for different kinds of data, we use different kinds of data structures. In this lesson, we are going to introduce you to another nonlinear data structure that has got its application in a wide number of scenarios in computer science.It is used to model and represent a variety of systems. And this data structure is graph. When we study data structures, we often first study them as mathematical or logical models.Here also, we will first study graph as a mathematical or logical model. And we will go into implementation details later. OK, so let's get started.A graph, just like a tree, is a collection of objects or entities that we call nodes or vertices connected to each other through a set of edges. But in a tree, connections are bound to be in a certain way. In a tree, there are rules dictating the connection among the nodes.In a tree with n nodes, we must have exactly n minus 1 edges, one edge for each parent-child relationship. As we know, an edge in a tree is for a parent-child relationship. And all nodes in a tree, except the root node, would have a parent, would have exactly one parent.And that's why if there are n nodes, there must be exactly n minus 1 edges. In a tree, all nodes must be reachable from the root. And there must be exactly one possible path from root to a node.Now, in a graph, there are no rules dictating the connection among the nodes. A graph contains a set of nodes and a set of edges. And edges can be connecting nodes in any possible way.Tree is only a special kind of graph. Now, graph as a concept has been studied extensively in mathematics. If you have taken a course on discrete mathematics, then you must be knowing about graphs already.In computer science, we basically study and implement the same concept of graph from mathematics. The study of graphs is often referred to as graph theory. In pure mathematical terms, we can define graph something like this.A graph G is an ordered pair of a set V of vertices and a set E of edges. Now, I'm using some mathematical jargon here. An ordered pair is just a pair of mathematical objects in which the order of objects in the pair matters.This is how we write and represent an ordered pair. Objects separated by comma put within parentheses. Now, because the order here matters, we can say that V is the first object in the pair and E is the second object.An ordered pair AB is not equal to BA unless A and B are equal. In our definition of graph here, first object in the pair must always be a set of vertices and the second object must be a set of edges. That's why we're calling the pair an ordered pair.We also have concept of unordered pair. An unordered pair is simply a set of two elements. Order is not important here.We write an unordered pair using curly brackets or braces because the order is not important here. Unordered pair AB is equal to BA. It doesn't matter which object is first and which object is second.OK, coming back. So a graph is an ordered pair of a set of vertices and a set of edges and G equal VE is a formal mathematical notation that we use to define a graph. Now, I have a graph drawn here in the right.This graph has eight vertices and 10 edges. What I want to do is I want to give some names to these vertices because each node in a graph must have some identification. It can be a name or it can be an index.I'm naming these vertices as V1, V2, V3, V4, V5, and so on. And this naming is not indicative of any order. There is no first, second, and third node here.I could give any name to any node. So my set of vertices here is this. We have eight elements in the set.V1, V2, V3, V4, V5, V6, V7, and V8. So this is my set of vertices for this graph. Now what's my set of edges? To answer this, we first need to know how to represent an edge.An edge is uniquely identified by its two endpoints. So we can just write the names of the two endpoints of an edge as a pair and it can be a representation for the edge. But edges can be of two types.We can have a directed edge in which connection is one way or we can have an undirected edge in which connection is two way. In this example graph that I'm showing here, edges are undirected. But if you remember the tree that I had shown earlier, then we had directed edges in that tree.With this directed edge that I'm showing you here, we are saying that there is a link or path from vertex u to v. But we cannot assume a path from v to u. This connection is one way. For a directed edge, one of the endpoints would be the origin and the other endpoint would be the destination. And we draw the edge with an arrowhead pointing towards the destination.For our edge here, origin is u and destination is v. A directed edge can be represented as an ordered pair. First element in the pair can be the origin and second element can be the destination. So with this directed edge represented as ordered pair u, v, we have a path from u to v. If we want a path from v to u, we need to draw another directed edge here with v as origin and u as destination.And this edge can be represented as ordered pair v, u. The upper one here is u, v and the below one is v, u. And they are not same. Now if the edge is undirected, the connection is two way. An undirected edge can be represented as an unordered pair.Here because the edge is bidirectional, origin and destination are not fixed, we only need to know what two endpoints are being connected by the edge. So now that we know how to represent edges, we can write the set of edges for this example graph here. We have an undirected edge between v1 and v2.Then we have one between v1 and v3. Then we have v1, v4. This is really simple.I'll just go ahead and write all of them. So this is my set of edges. Typically in a graph, all edges would either be directed or undirected.It's possible for a graph to have both directed and undirected edges, but we are not going to study such graphs. We are only going to study graphs in which all edges would either be directed or undirected. A graph with all directed edges is called a directed graph or digraph.And a graph with all undirected edges is called an undirected graph. There is no special name for an undirected graph. Usually if the graph is directed, we explicitly say that it's a directed graph or digraph.So these are two types of graph. Directed graph or digraph in which edges are unidirectional or ordered pairs. And undirected graph in which edges are bidirectional or unordered pairs.Now many real world systems and problems can be modeled using a graph. Graphs can be used to represent any collection of objects having some kind of pairwise relationship. Let's have a look at some of the interesting examples.A social network like Facebook can be represented as an undirected graph. A user would be a node in the graph and if two users are friends, there would be an edge connecting them. A real social network would have millions and billions of nodes.I can show only a few in my diagram here because I'm short of space. Now social network is an undirected graph because friendship is a mutual relationship. If I'm your friend, you are my friend too.So connections have to be two way. Now once a system is modeled as a graph, a lot of problems can easily be solved by applying standard algorithms in graph theory. Like here in this social network, let's say we want to do something like suggest friends to a user.Let's say we want to suggest some connections to Rama. One possible approach to do so can be suggesting friends of friends who are not connected already. Rama has three friends, Ella, Bob and Katie and friends of these three that are not connected to Rama already can be suggested.There is no friend of Ella which is not connected to Rama already. Bob, however, has three friends, Tom, Sam and Lee that are not friends with Rama. So they can be suggested.And Katie has two friends, Lee and Swati that are not connected to Rama. We have counted Lee already. So in all, we can suggest these four users to Rama.Now even though we described this problem in context of a social network, this is a standard graph problem. The problem here in pure graph terms is finding all nodes having length of shortest path from a given node equal to two. Standard algorithms can be applied to solve this problem.We'll talk about concepts like path in a graph in some time. For now, just know that the problem that we just described in context of a social network is a standard graph problem. Okay, so a social network like Facebook is an undirected graph.Now let's have a look at another example. Interlinked web pages on the internet or the World Wide Web can be represented as a directed graph. A web page that would have a unique address or URL would be a node in the graph.And we can have a directed edge if a page contains link to another page. Now once again, there are billions of pages on the web, but I can show only few here. The edges in this graph are directed because the relationship is not mutual this time.If page A has a link to page B, then it's not necessary that page B will also have a link to page A. Let's say one of the pages on mycodeschool.com has a tutorial on graph. And on this page, I have put a link to Wikipedia article on graph. Let's assume that in this example graph that I'm showing you here, page B is my MyCodeSchool tutorial on graph with this address or URL, mycodeschool.com slash videos slash graph.And let's say page Q is the Wikipedia article on graph with this URL, wikipedia.org slash wiki slash graph. Now on my page, that is page B, I have put a link to Wikipedia page on graph. If you are on page B, you can click on this link and go to page Q. But Wikipedia has not.