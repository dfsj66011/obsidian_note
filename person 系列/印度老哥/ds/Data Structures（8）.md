
## 37、二叉搜索树中的中序后继节点

在本节课中，我们将解决二叉搜索树上的另一个有趣问题：给定二叉搜索树中的一个节点，我们需要找到它的中序后继节点，即在二叉搜索树的中序遍历中紧接在该节点之后的节点。众所周知，在二叉树的中序遍历中，我们首先访问左子树，然后访问根节点，最后访问右子树。左右子树均以相同方式递归遍历。

因此，对于每个节点，我们首先访问其左子树，然后访问节点本身，最后访问其右子树。在本系列的前一节课中，我们已经详细讨论了中序遍历。你可以查看本视频的描述以获取相关链接。中序遍历的实现基本上是一个递归函数，类似于我在这里展示的内容。这个函数中有两个递归调用，一个用于访问左子树，另一个用于访问右子树。中序遍历的时间复杂度为O(n)，其中n是树中的节点数量。

我们访问每个节点恰好一次，因此所花费的时间与树中的节点数量成正比。我在这里画了一个整数的二叉搜索树。众所周知，二叉搜索树是一种二叉树，其中对于每个节点，左侧节点的值较小，右侧节点的值较大。让我们快速看看这个二叉搜索树的中序遍历会是什么样子。我们将从树的根节点开始。对于任何节点，我们首先需要访问其左侧的所有节点，然后才能访问该节点本身。

所以我们必须向左走。基本上，我们会递归调用以访问这个节点的左子节点。对于这个节点，我们再次发现左边有东西。因此，我们会进行另一个递归调用并访问它的左子节点。现在我们到达值为8的这个节点，我们需要再向左走一次。现在对于值为6的这个节点，它是一个叶子节点，左边没有任何东西。所以我们可以简单地认为它的左子树已经完成，因此我们可以访问这个节点。对我来说，访问就是读取该节点中的数据。我会在这里写下数据。


And now for this node, there is nothing in right as well. So we can simply say that its right is also done.And now we are completely done for this guy. So recursive call corresponding to this node will finish and we will go back to call corresponding to its parent. If we will come back to a node from its left child, then it will be unvisited.Because we can't visit a node until its left is done. So when we are coming back to 8, 8 is unvisited. So we can simply visit this node.That is read the data in this node. When I'll visit a node, I'll paint it in yellow. And now there is nothing in right of this node.So we can simply say that right is done. Now we are done with this node. So call corresponding to this node will finish and we will go back to its parent.Once again we are coming back to the parent from left. So the parent, that is this node with value 10 is unvisited. If we would come back to a node from right, then it would already be visited.So I'm visiting 10 and now we can go to right of 10. So far we have visited three nodes. We first visited node with value 6 and then we visited node with value 8. So 8 is successor of 6 and then 10 is successor of 8. Now let's see what will be the successor of 10.For nodes with values 6 and 8, there was nothing in right. So we were unwinding and going to the parent. But for a node if there would be something in right, that is if there would be a right subtree, then its successor would definitely be in its right subtree.Because after visiting that node we will go right. Now at this stage we are at this node with value 12. For this guy we will first go left and now we are at node with value 11 which is a leaf node.There is nothing in left. So we can simply say that left is done and we can print the data. That is visit this node.So in order successor of 10 is 11. Now for node with value 11 there is nothing in right. So we will go back to its parent and now we can visit this guy.So after 11 we have 12. There is nothing in right of 12. So call for this guy will finish and we will go to its parent.Now we are coming back to 10 again. But this time from right. So this guy is already visited.So we need not do anything, we can simply go to its parent. And now we are at this node with value 15. We are coming from left.This guy is unvisited. So we can visit it. And now we can go to its right.We will go on like this. Successor of 15 would be 16. And after 16 we will print 17.Then after 17 we will print 20. Then 25. And the last element would be 27.So this is in order traversal of this binary search tree. Notice that we have printed the integers in sorted order. When we perform in order traversal on a binary search tree, then elements are visited in sorted order.Now the problem that we want to solve is given a value in the tree, we want to find its in order successor. In a binary search tree, it would be the next higher value in the tree. But what's the big deal here? Can't we just perform in order traversal and while performing the traversal figure out the successor? Well, we can do so.But it will be expensive. Running time of in order is big O of n. And we may want to do better. Finding next and previous element in some data could be a frequently performed operation.And good thing about binary search tree is that frequently performed operations like insertion, deletion, and search happen in big O of h, where h is height of the tree. So it would be good if we are able to find successor and predecessor in big O of h. We always try to keep a tree balanced to minimize its height. Height of a balanced binary tree is log n to the base 2. And big O of log n running time for any operation is almost the best running time that we can have.So can we find in order successor in big O of h? I have redrawn the example tree here. Let's see what we can do in various cases. What node would we visit after this node with value 10? Can we deduce this logically? Well, if you remember the simulation of in order traversal that we had done earlier, then if we have already visited this node, then we are done with its left subtree.And we have read the data in this node. And we need to go right. Now in the right subtree, we will have to go left as long as it's possible to go.And if we can't go left anymore, like here, there's nothing left of this node with value 11. Then this is the node that I'm visiting next. So for our node, if there is a right subtree, then in order successor would be the leftmost node in its right subtree.In a BST, it would be the node with minimum value in its right subtree. I would say this is case one. In this case, all we need to do is we need to go as left as possible in right subtree.In a BST, it will also mean finding the minimum in right subtree. Leftmost node will also be the minimum in the subtree. Now this is one case.Our node here had a right subtree. What would be the successor if there would be no right subtree? What node would we visit after this node with value 8? This guy does not have a right subtree. If we have already visited this guy, then we have visited its left and this node itself.And there is nothing in right, so we can see that right is also visited. But we have not found the successor yet. Now where do we go from here? Well, if you remember the simulation that we had done earlier, we need to go to the parent of this node.And if we are going to the parent from left, which is the case here, then the parent would be unvisited. For this node with value 10, we just finished its left subtree and we are coming back. So now we can visit this node.So this is my successor. Let's now pick another node with no right subtree. What would be not a successor of this node with value 12? What node would we visit next? Now here, once again, we do not have a right subtree for this node.So we must go back to its parent and see if it's unvisited. But if we're going to the parent from right, if the node that we just visited is a right child, which is the case here, then the parent would already be visited. Because we are coming back after visiting its right subtree.This node must have been visited before going right. So what should we do? Now the recursion will roll back further and we need to go to parent of 10. And now we're going to 15 from left.So this guy is unvisited. So we can visit this node and this is my successor. If the node does not have a right subtree, we need to go to the nearest ancestor for which given node would be in its left subtree.Here for 12, we first went to 10. But 12 is in right subtree of 10. So we went to the next ancestor, 15.And 12 is in left of 15. So this is the nearest ancestor for which 12 is in left. And hence, this is my inorder successor.This algorithm works fine, but there is an issue. How do we go from a node to its parent? Well, we can design our tree such that node can have reference to its parent. So far, in most lessons, we have defined node as a structure with three fields, something like this.This is how we would define node in C or C++. We have one field to store data and we have two pointers to node to store reference or addresses of left and right children. Often it makes a lot of sense to have one more field to store the address of parent.We can design our tree like this and then we will not have problem walking the tree up using parent link. We can easily go to the ancestors. But what if there is no link to parent? In this case, what we can do is we can start at root and walk the tree from root to the given node.In a BSD, this is really easy. For 12, we will start at root. 12 is lesser than value in root.So we need to go left. And now we are at 10. Now 12 is greater than 10, so we need to go right.And now we are at 12. If we will walk the tree from root to the given node, we will go through all the ancestors of the given node. Inorder successor would be the deepest node or deepest ancestor in this path for which given node would be in left subtree.12 has only two ancestors. We have 10, but 12 is in right of 10. And then we have 15, and 12 is in left of 15.So 15 is my successor. Now let's use this technique to find successor of 6. We will first walk down from root to this node. 6 is in left for all the ancestors.But deepest ancestor for which 6 is in left is this node with value 8. So this is my successor. Remember, we need to look at ancestors only if there is no right subtree. For 6, there is no right subtree.OK, so the algorithm looks good. Let's now write code for this. In my C++ code here, I'm going to write a function named get successor that will take address of root node and address of another node for which we need to find the successor.And this function will return address of the successor node. We could design this function differently. Instead of taking pointer to the node for which we want to find the successor as argument, we could just take the data as argument.And for this data, for this element, we can find the successor node and return its address. And that's why the return type here is struct node asterisk because we will be returning address in a pointer. Or what we can also do is we can return the element itself, the successor element itself.We can implement with any of these signatures. Let's implement this one. We will pass the data in current node.And we will return back the address of the successor. Now the first thing that we need to do is we need to search the node with this data. I'm going to make call to a function named find that will take address of the root node and the data and will return me pointer to the node with this data.If this function returns me null, that is if the data is not found in the tree, we can simply return null. Else, we have the address of the current node in this pointer to node that we have named current. Now in a BSD, this search operation will cost us big O of h, where h is height of the tree.Search in a BSD is not very expensive. We could have avoided this search if we would have passed address of the current node instead of passing the data as the second argument. But let's go with this.Let's now find the successor of this node. If this node has right subtree, that is if the right subtree is not null, we need to go to the leftmost node in the right subtree. I have declared a temporary pointer to node here and initially I've set it to current.right. And with this while loop, I'll go to the leftmost node.While there is something in the left, keep going. And finally, when I'll come out of this loop, I'll have address of leftmost node in the right subtree and I can return this address. This particular node will also be the node with minimum value in right subtree.I'll move this code in another function. I have written this function named findMin that will return node with minimum value in a tree or subtree. In getSuccessor function, I'll simply say return findMin and I'll pass the address of right child of current node.So basically, I'm passing the right subtree here. OK, now let's talk about case two. If there is no right subtree, what we need to do is we need to walk the tree from root till current node and we need to find the deepest ancestor for which current node will be in its left subtree.What I'm going to do here is I'm going to declare a pointer to node named successor and initially I'll set it as null and I'll have another pointer to node named ancestor and initially I'll set this as root. And with this while loop, we will walk the tree till we have not reached the current node. To walk the tree, we will use the property of binary search tree that for each node, value of nodes in left is lesser and value of nodes in right is greater.If data in current node is less than the data in ancestor, then first of all, this ancestor may be my in order successor because the current node is in its left. So, what we can do is we can set this guy as successor and we can go left while traversing if we will find a deeper node with this property that current node will be in its left subtree, then successor will be updated. Else, if the current node lies in right, we simply need to move right.When we'll come out of this while loop, successor will either be null or it will be the address of some node. Not all nodes in the tree will have a successor. Node with maximum value will not have a successor.After coming out of this while loop, we can return the successor. So, this is my getSuccessor function and I think this should work. You can find link to complete source code in description of this video.Overall, time complexity of this function will be O of H. And this is what we wanted. We wanted to find successor in O of H. Here, we are already performing the search in O of H. Finding minimum will also take O of H and walking the tree from root to a node in BST will also take O of H. So, overall this is O of H. If you have understood this code, this logic, then it should be very easy for you writing function to find in order predecessor. I encourage you to write it.I'll stop here now. In coming lessons, we will solve some more interesting problems on binary trees and binary search trees. Thanks for watching.Hello everyone. So far in this series on data structures, we have talked about some of the linear data structures like array, linked list, stack, and queue. In all these structures, data is arranged in a linear or sequential manner.So we can call them linear data structures. And we've also talked about tree, which is a nonlinear data structure. Tree is a hierarchical structure.Now as we understand, data structures are ways to store and organize data. And for different kinds of data, we use different kinds of data structures. In this lesson, we are going to introduce you to another nonlinear data structure that has got its application in a wide number of scenarios in computer science.It is used to model and represent a variety of systems. And this data structure is graph. When we study data structures, we often first study them as mathematical or logical models.Here also, we will first study graph as a mathematical or logical model. And we will go into implementation details later. OK, so let's get started.A graph, just like a tree, is a collection of objects or entities that we call nodes or vertices connected to each other through a set of edges. But in a tree, connections are bound to be in a certain way. In a tree, there are rules dictating the connection among the nodes.In a tree with n nodes, we must have exactly n minus 1 edges, one edge for each parent-child relationship. As we know, an edge in a tree is for a parent-child relationship. And all nodes in a tree, except the root node, would have a parent, would have exactly one parent.And that's why if there are n nodes, there must be exactly n minus 1 edges. In a tree, all nodes must be reachable from the root. And there must be exactly one possible path from root to a node.Now, in a graph, there are no rules dictating the connection among the nodes. A graph contains a set of nodes and a set of edges. And edges can be connecting nodes in any possible way.Tree is only a special kind of graph. Now, graph as a concept has been studied extensively in mathematics. If you have taken a course on discrete mathematics, then you must be knowing about graphs already.In computer science, we basically study and implement the same concept of graph from mathematics. The study of graphs is often referred to as graph theory. In pure mathematical terms, we can define graph something like this.A graph G is an ordered pair of a set V of vertices and a set E of edges. Now, I'm using some mathematical jargon here. An ordered pair is just a pair of mathematical objects in which the order of objects in the pair matters.This is how we write and represent an ordered pair. Objects separated by comma put within parentheses. Now, because the order here matters, we can say that V is the first object in the pair and E is the second object.An ordered pair AB is not equal to BA unless A and B are equal. In our definition of graph here, first object in the pair must always be a set of vertices and the second object must be a set of edges. That's why we're calling the pair an ordered pair.We also have concept of unordered pair. An unordered pair is simply a set of two elements. Order is not important here.We write an unordered pair using curly brackets or braces because the order is not important here. Unordered pair AB is equal to BA. It doesn't matter which object is first and which object is second.OK, coming back. So a graph is an ordered pair of a set of vertices and a set of edges and G equal VE is a formal mathematical notation that we use to define a graph. Now, I have a graph drawn here in the right.This graph has eight vertices and 10 edges. What I want to do is I want to give some names to these vertices because each node in a graph must have some identification. It can be a name or it can be an index.I'm naming these vertices as V1, V2, V3, V4, V5, and so on. And this naming is not indicative of any order. There is no first, second, and third node here.I could give any name to any node. So my set of vertices here is this. We have eight elements in the set.V1, V2, V3, V4, V5, V6, V7, and V8. So this is my set of vertices for this graph. Now what's my set of edges? To answer this, we first need to know how to represent an edge.An edge is uniquely identified by its two endpoints. So we can just write the names of the two endpoints of an edge as a pair and it can be a representation for the edge. But edges can be of two types.We can have a directed edge in which connection is one way or we can have an undirected edge in which connection is two way. In this example graph that I'm showing here, edges are undirected. But if you remember the tree that I had shown earlier, then we had directed edges in that tree.With this directed edge that I'm showing you here, we are saying that there is a link or path from vertex u to v. But we cannot assume a path from v to u. This connection is one way. For a directed edge, one of the endpoints would be the origin and the other endpoint would be the destination. And we draw the edge with an arrowhead pointing towards the destination.For our edge here, origin is u and destination is v. A directed edge can be represented as an ordered pair. First element in the pair can be the origin and second element can be the destination. So with this directed edge represented as ordered pair u, v, we have a path from u to v. If we want a path from v to u, we need to draw another directed edge here with v as origin and u as destination.And this edge can be represented as ordered pair v, u. The upper one here is u, v and the below one is v, u. And they are not same. Now if the edge is undirected, the connection is two way. An undirected edge can be represented as an unordered pair.Here because the edge is bidirectional, origin and destination are not fixed, we only need to know what two endpoints are being connected by the edge. So now that we know how to represent edges, we can write the set of edges for this example graph here. We have an undirected edge between v1 and v2.Then we have one between v1 and v3. Then we have v1, v4. This is really simple.I'll just go ahead and write all of them. So this is my set of edges. Typically in a graph, all edges would either be directed or undirected.It's possible for a graph to have both directed and undirected edges, but we are not going to study such graphs. We are only going to study graphs in which all edges would either be directed or undirected. A graph with all directed edges is called a directed graph or digraph.And a graph with all undirected edges is called an undirected graph. There is no special name for an undirected graph. Usually if the graph is directed, we explicitly say that it's a directed graph or digraph.So these are two types of graph. Directed graph or digraph in which edges are unidirectional or ordered pairs. And undirected graph in which edges are bidirectional or unordered pairs.Now many real world systems and problems can be modeled using a graph. Graphs can be used to represent any collection of objects having some kind of pairwise relationship. Let's have a look at some of the interesting examples.A social network like Facebook can be represented as an undirected graph. A user would be a node in the graph and if two users are friends, there would be an edge connecting them. A real social network would have millions and billions of nodes.I can show only a few in my diagram here because I'm short of space. Now social network is an undirected graph because friendship is a mutual relationship. If I'm your friend, you are my friend too.So connections have to be two way. Now once a system is modeled as a graph, a lot of problems can easily be solved by applying standard algorithms in graph theory. Like here in this social network, let's say we want to do something like suggest friends to a user.Let's say we want to suggest some connections to Rama. One possible approach to do so can be suggesting friends of friends who are not connected already. Rama has three friends, Ella, Bob and Katie and friends of these three that are not connected to Rama already can be suggested.There is no friend of Ella which is not connected to Rama already. Bob, however, has three friends, Tom, Sam and Lee that are not friends with Rama. So they can be suggested.And Katie has two friends, Lee and Swati that are not connected to Rama. We have counted Lee already. So in all, we can suggest these four users to Rama.Now even though we described this problem in context of a social network, this is a standard graph problem. The problem here in pure graph terms is finding all nodes having length of shortest path from a given node equal to two. Standard algorithms can be applied to solve this problem.We'll talk about concepts like path in a graph in some time. For now, just know that the problem that we just described in context of a social network is a standard graph problem. Okay, so a social network like Facebook is an undirected graph.Now let's have a look at another example. Interlinked web pages on the internet or the World Wide Web can be represented as a directed graph. A web page that would have a unique address or URL would be a node in the graph.And we can have a directed edge if a page contains link to another page. Now once again, there are billions of pages on the web, but I can show only few here. The edges in this graph are directed because the relationship is not mutual this time.If page A has a link to page B, then it's not necessary that page B will also have a link to page A. Let's say one of the pages on mycodeschool.com has a tutorial on graph. And on this page, I have put a link to Wikipedia article on graph. Let's assume that in this example graph that I'm showing you here, page B is my MyCodeSchool tutorial on graph with this address or URL, mycodeschool.com slash videos slash graph.And let's say page Q is the Wikipedia article on graph with this URL, wikipedia.org slash wiki slash graph. Now on my page, that is page B, I have put a link to Wikipedia page on graph. If you are on page B, you can click on this link and go to page Q. But Wikipedia has not.