
## 32、二叉树的遍历-广度和深度优先

在本课中，我们将讨论二叉树的遍历。当我们处理树结构时，经常需要访问树中的所有节点。现在，树不像数组或链表那样是一种线性数据结构。在线性数据结构中，会有一个逻辑起点和逻辑终点。因此，我们可以从一个端点开始移动指针，并持续向另一个端点移动。

对于像链表这样的线性数据结构，每个节点或元素只有一个下一个元素。但树不是线性数据结构。我这里画了一棵二叉树，这次数据类型是字符，我在节点中填入了这些字符。

对于任意时刻的树来说，如果我们指向某个特定节点，就可能存在多个可能的方向，即存在多个可能的下一节点。以这棵二叉树为例，如果我们从根节点开始指向，就有两个可能的方向。从F出发，既可以向左走到D，也可以向右走到J。当然，如果我们选择了一个方向前进，之后必然需要以某种方式返回并探索另一个方向。

因此，树的遍历并不那么简单直接。本节课我们将要讨论的是树的遍历算法。树遍历可以正式定义为按照某种顺序访问树中每个节点且仅访问一次的过程。所谓访问一个节点，指的是读取或处理该节点中的数据。在本节课中，访问意味着打印节点中的数据。根据访问节点的顺序，树遍历算法大致可以分为两类。

我们可以选择广度优先，也可以选择深度优先。广度优先遍历和深度优先遍历是遍历或搜索图的通用技术。图是一种数据结构，在本系列中我们尚未讨论过图。我们将在后续课程中讨论图。现在你只需要知道树只是图的一种特殊形式。本节课我们将讨论树的广度优先遍历和深度优先遍历。

在树的广度优先遍历中，我们会先访问同一深度或层级的所有节点，然后再访问下一层级的节点。以这棵二叉树为例，值为f的根节点位于第0层（此处标记为L0）。节点的深度定义为从根节点到该节点的路径上的边数，因此根节点的深度为0。图中D和J这两个节点的深度为1，所以我们称它们位于第1层。

现在这四个节点位于第二层，这三个节点位于第三层。最后，这个值为h的节点位于第四层。因此，在广度优先方法中，我们可以从第零层开始，第零层只有一个节点，即根节点。这样我们就可以访问根节点，我会在访问时写下节点中的值。现在第零层已经完成。接下来我可以进入第一层，从左到右访问节点。因此在F之后，我们会访问D，然后是J。现在第一层就完成了。接着我们可以进入第二层，依次访问B、E、G和K。然后我们可以进入第三层，访问A、C和I。最后我可以进入第四层。这种树的广度优先遍历在树的情况下被称为层序遍历。

我们将讨论如何通过编程实现这一点。但这是访问节点的顺序，我们会从左到右逐层进行。在广度优先方法中，对于任何节点，我们会先访问其所有子节点，然后再访问其孙节点。在这棵树中，我们首先访问F，然后访问D，接着不会沿着深度方向访问D的任何子节点，比如B或E。接下来我们会访问J。但在深度优先的方法中，如果我们访问一个子节点，我们会先完整遍历该子节点的整个子树，然后再访问下一个子节点。在这个例子中，从根节点F出发，如果我们向左访问D，那么我们应该先完整遍历这个左子树的所有节点，也就是要彻底完成这个左子树的深度遍历。

换句话说，我们应该沿着这条路径完成F的所有孙子节点，然后再去F的右子节点J。而当我们再次到达J时，我们将沿着这条路径访问所有的孙子节点。因此，基本上我们将访问完整的右子树。在深度优先的方法中，访问左子树、右子树和根节点的相对顺序可能会有所不同。例如，我们可以先访问右子树，然后访问根节点，再访问左子树。或者我们可以采取另一种方式，比如先访问根节点，然后访问左子树，最后访问右子树。因此，相对顺序可以有所不同。

但深度优先策略的核心思想是，访问一个子节点就意味着访问该路径下的整个子树。记住，访问一个节点就是读取、处理或打印该节点中的数据。根据左子树、右子树和根节点的相对顺序，有三种常见的深度优先策略。

一种方法是我们可以先访问根节点，然后访问左子树，再访问右子树，左右子树将以同样的方式递归访问。这种遍历称为前序遍历。另一种方法是我们可以先访问左子树，然后访问根节点，最后访问右子树。这种遍历方式被称为中序遍历。如果根节点在左子树和右子树之后被访问，那么这种遍历方式被称为后序遍历。总共有六种可能的左、右和根节点的排列组合。

但按照惯例，左子树总是先于右子树被访问。所以我们采用了这三种遍历策略。唯一变化的是根节点的位置：如果根节点位于左右子树之前，就是前序遍历；如果根节点位于左右子树之间，就是中序遍历；如果根节点位于左右子树之后，就是后序遍历。记住这三种深度优先算法有一个简单的方法。我们可以用字母D表示访问节点或读取该节点中的数据，用L表示进入左子树，用R表示进入右子树。因此，如果我们用D表示数据，L表示左，R表示右，那么在先序遍历中，对于每个节点，我们将按照DLR的顺序进行。首先，我们将读取该节点中的数据，然后进入左子树。

一旦左子树完成，我们将向右移动。在中序遍历中，首先我们会完成左子树，然后读取当前节点的数据，接着向右移动。在后序遍历中，对于每个节点，我们首先会向左移动。一旦左子树完成，我们将向右移动。然后我们将读取当前节点的数据。前序遍历的顺序是数据、左、右；中序遍历的顺序是左、数据、右；后序遍历的顺序是左、右、数据。使用递归来实现前序、中序和后序遍历非常简单直观。但我们稍后再讨论具体实现。现在让我们看看我在这里画的这棵树的前序、中序和后序遍历结果会是什么。

我们先来看看这棵二叉树的前序遍历是怎样的，需要从根节点开始。对于每个节点，我们首先需要读取数据，或者说访问该节点。实际上，这里我们不说DLR，也可以说VLR，这里的V代表访问（visit），我们可以使用这些假设中的任何一种——V代表访问或D代表数据，在这里我将使用DLR。

那么让我们从根节点开始。对于每个节点，我们首先需要读取数据。我在这里写下了F，也就是我刚读取的数据。然后我需要向左遍历，完成整个左子树。只有当左子树的所有节点都被访问过后，我才能转向右子树。这个问题实际上是以自相似或递归的方式在逐步简化。

现在我们需要关注这个左子树。现在我们位于F的左子树的根节点D。再次强调，对于这个节点，我们首先读取数据。现在我们可以向左走，只有当这三个节点A、B和C处理完毕后，我们才会前往E。现在我们专注于由这三个节点组成的子树。现在我们位于B，可以读取数据。然后我们可以向左走到A，A的左侧没有内容。因此可以说，对于A的左子树已经处理完毕。

右边也没有任何东西。所以我们可以说右边也完成了。现在对于B来说，左子树已经完成。所以我们可以向右移动到C，而C的左右都是空的。现在对于D来说，左子树已经完成。所以我们可以向右移动。对于E来说，左右两边再次为空。现在到了F的阶段，左子树已经遍历完毕，所以我们可以转向右边。接下来我们需要访问J的左侧，而G的左侧已经没有节点，因此可以转向右侧。现在我们可以转向I的左侧。对于H来说，左右两边都没有节点。此时，I的左子树已经完成遍历。

而右子树为空。现在我们可以回到 J，J 的左子树已经处理完毕。因此我们可以处理它的右子树。最后，我们在这里有 K，所有节点都已处理完毕。这就是我们手动执行前序遍历的方式。实际实现将是一个简单的递归过程。我们稍后再讨论这个问题。现在让我们来看看这棵二叉树的中序遍历会是什么样子。在中序遍历中，我们会先访问完左子树，然后访问当前节点，最后再访问右子树。

我们再次从根部开始，首先向左走。现在我们将先完成这个子树。对于D节点，我们再次首先向左走到B，然后从B走到A。对于A节点，左边已经没有内容了。所以我们可以说这个节点的左子树已经遍历完毕。现在我们可以读取数据了。接着我们可以转向它的右侧。

我们再次从根节点开始，首先向左走。现在我们将先完成这个子树。对于D节点，我们再次先向左走到B节点，然后从B节点走到A节点。现在对于A节点，左边已经没有节点了。所以我们可以说这个节点的左子树已经遍历完成。然后我们可以读取数据。现在我们可以向右走了。

但右边也没有东西。所以这个节点就完成了。现在B的左子树完成了，我们可以读取数据。现在对于B我们可以向右走。对于C再次检查，左边没有东西了，所以我们可以读取数据。而且右边也没有东西。现在D的左边已经完全处理完毕，我们可以访问它并在这里读取数据。现在我们可以向右走到E。对于E来说，左右子树再次为空。在这个阶段，F的左子树已经处理完毕。

这样我们就能读取数据了。现在我们可以移动到F的右侧。如果我们继续这样操作，最终就会得到中序遍历的结果。我这里展示的这棵树实际上是一棵二叉搜索树。对于每个节点来说，左侧节点的值较小，右侧节点的值较大。因此，如果我们按照左子树、当前节点、右子树的顺序打印，就会得到一个有序列表。对二叉搜索树进行中序遍历会给你一个有序列表。

好的，现在你应该能理解后序遍历了。这就是后序遍历的结果。我留给你自己验证这个结果是否正确。今天就讲到这里。下节课我们将讨论这些树遍历算法的实现。感谢观看。

## 32、二叉树的遍历

In this lesson, we are going to write code for level order traversal of a binary tree. As we have discussed in our previous lesson in level order traversal, we visit all nodes at a particular depth or level in the tree before visiting the nodes at next deeper level. For this binary tree that I'm showing here, if I have to traverse the tree and print the data in nodes in level order, then this is how we will go.

We will start at level zero and print F and now we are done with level zero so we can go to level one and we can visit the nodes at level one from left to right. From F we will go to D and from D we will go to J. Now level one is done so we can go to level two. So we will go like B, E, G and then K and now we can go to next.


ds-14

