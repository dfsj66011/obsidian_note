
双指针是一种常见的面试技巧，通常用于解决涉及可迭代数据结构（如数组）的特定问题。顾名思义，该技术使用两个（或更多）指针遍历数据结构。它并不一定需要物理上使用两个指针。只要另一个指针可以从现有值（如另一个指针的索引）轻松计算出来，就属于双指针问题。

由于“双指针”是一个较为宽泛的主题，因此并没有一种固定的实现方式。根据你遇到的问题不同，你需要采用不同的实现方法。一般来说，双指针算法具有以下特点：

1. 两个移动的指针，无论方向如何，可以相互依赖或独立移动；
2. 一个利用这两个指针所引用条目的函数，该函数以某种方式与答案相关联；
3. 一种简单的方法来决定移动哪个指针；
4. 当指针移动时处理数组的方法。

双指针问题的分类方法有很多。以下是一些分类方式，虽然并不全面。

## 分类

### 同向

这些问题有两个指针朝同一方向移动。以下是一个同方向双指针问题的示例：移除重复项。

**解题思路大致是：** 设置快慢指针，快指针向右移动，当快指针与慢指针内容不同时，向右移动慢指针，同时用快指针内容替换慢指针所在位置的值。当快指针到结束时，从头到慢指针位置即结果。

这与上述模型如何契合？嗯，这个问题中使用的函数是比较快指针的值与其前一个条目，看它们是否匹配。两个指针的移动条件是：如果前一次检查匹配，则只有快指针移动。否则，慢指针移动，执行将慢指针处的值设置为快指针处的值的操作，然后快指针移动。

当快指针到达末尾时程序结束，此时返回慢指针之后的索引作为数组的大小。

### 反向

这些问题有两个指针，它们朝相反的方向移动。下面是一个相反方向双指针问题的例子：已排序数组的两数之和。例如，`[2, 3, 4, 5, 6, 11, 18]`，目标和是 8

**解题思路大致是：** 左右指针各自在头尾处，如果 sum > target，向左移动右指针，反之移动左指针.

这次，函数将条目的总和与期望金额进行比较。如果总和较大，则移动较大的指针；如果总和较小，则移动较小的指针。如果总和相等，我们就找到了答案，并停止程序。

### 双指针 vs 滑动窗口

滑动窗口问题与同方向双指针问题类似，区别在于函数作用于两个指针之间的整个区间。不过通常情况下，我们会追踪窗口的累积结果，每次在窗口中添加或移除一个元素时，只需根据变化更新窗口，而不需要重新计算所有内容。

例如，"无重复字符的最长子串"就是一个经典的滑动窗口问题。例如从 `[A, B, C, D, B, E, A]`

**解题思路大致是：**

快慢指针初始在左端，快指针向右移动，只要没有遇到重复的就移动，并标注 longest 变量，当遇到重复时，如 fast 处于第二个 B，slow 向右移动，直到排除掉 B，即处于 C，则 fast 继续向右移动。

在该解决方案中，我们持续追踪窗口内出现的字符数量。我们移动后指针，将元素插入集合，直到出现重复字符。然后移动前指针，从集合中移除元素，直到能重新插入该元素。同时每次都会记录最大窗口尺寸作为最终答案。

### 非数组应用

双指针技术不仅限于数组。只要是可以迭代的结构，比如链表，都可以使用双指针。

例如，在《链表循环》问题中，你需要检测链表结构中是否存在循环，这可以通过一种名为弗洛伊德循环检测算法的双指针技巧来解决。

## Why

双指针技术之所以有用，是因为它通常能提供比朴素解法更高效的解决方案。从上述例子可以看出，如果我们采用朴素解法并使用双重循环遍历数组，时间复杂度通常会是 $O(n²)$，这往往难以满足需求。而使用双指针处理这类问题时，通常只需让两个指针遍历数组一次，这意味着时间复杂度往往能降至$O(n)$。
