

### 个人的 Dijkstra 算法

按模式进行分类。通过这种方式，我们可以确定最常被测试和投资回报率（ROI）最高的领域，以便集中精力。

![interview questions overall breakdown](https://algo.monster/top_overall_pattern_chart.png)
我们根据上述分析制作了一份投资回报率表格以供参考。
![](https://assets.algo.monster/stats.png)
### 最高 ROI：DFS、BFS、双指针

DFS、BFS 和双指针法构成了面试题中的很大一部分。尤其是 DFS，可用于解决从树到图再到组合问题的广泛问题，在技术面试中非常有用。我们对这些主题都有详细的讲解。

### Basic DSA 的 ROI 回报率非常高

Basic DSAs 包括：链表、数组、哈希表、栈、队列、排序

掌握这些概念就能应对大多数简单的编程面试。每个主题下的变体也不多。例如，链表类目下就有反转链表、寻找链表中点节点、检测链表循环等几个经典问题会被反复考察。许多基础数据结构与算法在日常编码任务中也会频繁使用。大多数具备一定编程经验的人应该已经熟悉这些概念。因此我们将减少在这些主题上的讲解时间。

### 优先队列/堆的 ROI 中等

优先级队列和堆的出现频率比大多数人想象的要高得多。经典问题包括数据流的中位数、k closest points 等。

### 贪婪算法，动态规划

DP 很难概括，而且并不经常出现（除非你在谷歌面试，那里的工程师喜欢问 DP 问题）。有几个经典问题你可能需要了解，比如“打家劫舍（house robber）”和“机器人路径（robot paths）”。否则，如果你时间紧张，或许应该专注于投资回报率更高的领域。另外，如果你无法想出动态规划的解决方案，你总是可以采用深度优先搜索（DFS）加记忆化的方法，效果是一样的。

每个贪心问题都各不相同，很难总结出固定模式。你的解法是否正确通常需要严格的数学证明，而这很难在短时间内掌握。因此，我们认为贪心问题的 ROI 不高。

### 高级数据结构，如字典树(trie) 和并查集(union find)

这些情况并不常见，但确实会出现。可以把它们视为次要优先级。

Dijkstra 算法用于在加权图中查找节点之间的最短路径。虽然加权图的面试题存在但较为少见。由于该算法使用了经常被问到的优先队列，对其有一个高层次的理解是很有帮助的。

Robin Karp 滚动哈希算法有时有助于解决一些双指针问题。

-------

## 8 种模式，代码模板

编码面试中最重要的 *八种* 模式，涵盖 LeetCode 题目的两大类别：

* 线性类（适用于数组、链表、字符串等线性数据结构）：双指针、滑动窗口、二分搜索
* 非线性类（适用于树和图等非线性数据结构）实际上，与其将树和图视为两种完全不同的结构，不如想象树只是一个没有环的图。两者之间的唯一区别在于，对于可能有环的图，你需要一些访问集来跟踪已经访问过的节点。



### 1、双指针模式

所有线性结构的模式都基于双指针技术，双指针模式之所以重要，是因为它能显著降低涉及遍历线性结构（如数组、链表或字符串）问题的时间复杂度。相较于暴力解法可能需要检查元素的每一种组合（可能导致 $O(N^2)$ 的时间复杂度），双指针通常能在 $O(N)$ 的线性时间内解决问题，效率极高。

双指针主要有 *两种* 使用方式：指针可以 *同向移动* 或 *相向移动*，分别适用于不同类型的问题。

同向移动：当指针同向移动时，这种技术非常适合需要单次扫描或处理数据的问题。一个典型的应用场景是使用 *快慢指针* 检测链表中的循环，或者寻找链表的中间节点。慢指针每次移动一步，而快指针每次移动两步。这样可以在不重复遍历结构的情况下高效地检查循环或找到关键元素。

反向移动：通常用于 *涉及查找配对* 或比较数据结构两端元素的问题。一个典型的例子是在一个已排序的数组中找到两个数，它们的 *和等于目标值*。一个指针从数组的开头开始，另一个指针从数组的末尾开始。根据当前的和，逐步将指针向内移动，可以迅速锁定正确的数字对，从而避免不必要的比较。

### 2、滑动窗口模式

滑动窗口模式是双指针模式的扩展，但具有更聚焦的目的。双指针涉及使用两个独立的指针来遍历和操作数据结构，而滑动窗口则 *通过维护数据中的一个元素窗口* 来优化这一过程，随着在结构中的推进动态调整其大小。本质上，你仍然在使用两个指针，但目标在于管理满足特定条件的元素范围或子集，例如子数组或子字符串。

在滑动窗口方法中，一个指针标记窗口的起始位置，另一个指针标记窗口的结束位置。随着结束指针的移动，窗口会在数据结构上滑动。根据具体问题，你可以通过移动结束指针来扩大窗口，或者通过移动起始指针来收缩窗口，以满足特定条件，例如最大化子字符串的长度或将总和保持在目标值范围内。

例如，在一个需要找到不重复字符的最长子串的问题中，窗口通过移动结束指针来包含新字符从而扩展。如果窗口遇到重复字符，起始指针向前移动以缩小窗口并消除重复。这种动态过程使你能够高效地解决需要分析数组或字符串连续段的问题，而无需多次重新遍历结构。

滑动窗口算法在需要 *追踪连续序列的问题* 上极为强大，无论是处理字符串、子数组还是链表。它通过让你在任何给定时刻控制一个元素范围，为双指针模式增添了更多灵活性，并且 *常与哈希表结合使用* 来跟踪窗口内的元素。

### 3、二分搜索

二分搜索是一种基础搜索算法，通过在排序数组中不断将列表对半分来查找目标值。从技术上讲，这也是双指针模式的扩展，因为它使用了左右两个指针逐步将列表一分为二。二分查找首先查看中间元素，并检查它是否是目标值。如果是目标值，则查找成功，可以直接返回。如果它比目标小，你就知道目标在右侧某处，于是我们重复这个过程，但仅限于右半部分。如果它比目标大，我们就在左侧重复这个过程。最终，我们会收敛到目标上。

这是一种高效的算法，因为它允许我们在对数时间（$O(\log n)$）内找到目标，而不是逐个元素搜索（$O(n)$）。然而，二分查找的适用范围远不止于已排序的数字列表。二分查找之所以极其强大，是因为它可以应用于 *任何具有单调函数* 的列表。单调函数是指任何具有一致递增或递减模式的函数，这种模式不仅限于数字。简单来说，我们寻找的是任何可用于排序的条件，而不仅仅是严格递增的数字。例如，如果我们有一个只包含真和假的排序列表，我们实际上可以使用二分查找来找到第一个为真的元素。

**模板：**

```python
def binary_search(arr: List[int], target: int) -> int:
    left, right = 0, len(arr) - 1
    first_true_index = -1
    
    while left <= right:
        mid = (left + right) // 2
        if feasible(mid):
            first_true_index = mid
            right = mid - 1
        else:
            left = mid + 1

    return first_true_index

```


例如，LeetCode 上常见的“旋转排序数组中的最小值”问题，乍一看似乎并不适用于二分查找。毕竟，数组并未完全有序。但实际上，我们可以利用其中的单调性条件来应用二分查找算法。条件是，任何小于数组最后一个元素的元素都属于旋转部分，而任何大于最后一个元素的元素都属于原始有序部分。我们可以将其在脑海中转换为真假值，就像这样，我们就得到了刚才解决的相同真假问题。这种方法可以应用于大量不同的问题。

### 4、BFS

广度优先搜索是一种用于逐层探索图或树中节点的算法。其背后的理念是，算法从一个给定的节点（通常称为根节点）开始，首先探索其所有直接相邻的节点，然后再继续探索这些相邻节点的相邻节点，以此类推。为了记录已经访问过的节点以避免重复访问，BFS 使用了一种称为队列的数据结构，其工作原理类似于排队——先进先出。

**模板：**

```python
def bfs(root):
    queue = deque([root])
    while len(queue) > 0:
        node = queue.popleft()
        for child in node.children:
            if is_goal(child):
                return FOUND(child)
            queue.append(child)
    return NOT_FOUND

```

### 5、DFS

BFS 专注于逐层探索节点，而 DFS 会沿着一条路径尽可能深入探索，然后再探索下一条路径。相比之下，DFS 使用栈以深度优先的方式探索节点。它会沿着一条分支一直向下探索直到尽头，然后再回溯探索其他分支。大多数情况下，DFS 使用的栈是 call stack，因为大多数 DFS 实现都采用递归方式。

BFS 适合寻找最短路径或逐层探索节点，而 DFS 更适合需要探索所有路径或检查每种可能配置的问题，例如查找树中的所有路径、在结构深处搜索特定条件或检测循环。DFS 的深度优先特性使其在某些情况下更节省内存，但对于需要最短路径或浅层探索的问题则不太适用，因为它不能保证首先找到最近的解决方案。

**模板：**

```python
# 适用于树问题的 DFS 模板
def dfs(root, target):
    if root is None:
        return None
    if root.val == target:
        return root
    left = dfs(root.left, target)
    if left is not None:
        return left
    return dfs(root.right, target)
    
------------


```

一个常见的使用这种模式的 LeetCode (200) 问题叫做“岛屿数量”。这个问题要求我们计算一个二维网格中的岛屿数量，其中 1 代表陆地，0 代表水域。岛屿是通过水平或垂直连接相邻的 1 形成的。我们需要通过识别网格中 1 的连通分量来确定有多少个不同的岛屿。例如，在网格中，一些 1 被分组在一起，每个相连的组被视为一个岛屿。我们的目标是遍历网格，找到所有岛屿并统计数量。

我们可以通过 DFS 来探索每个岛屿。具体思路是遍历网格中的每一个单元格。当我们遇到一个 1 时，表示发现了一个岛屿的起点。从这里开始，我们通过 DFS 访问所有相连的 1，即同一岛屿的所有部分，方法是向四个方向探索相邻的单元格，直到无法继续深入为止。在 DFS 过程中，我们将每个访问过的单元格的值改为 0，以确保不会重复计数。一旦该岛屿的所有相连单元格都被访问过，我们就增加岛屿计数，并继续搜索网格的其余部分。这个过程确保了我们只探索每个岛屿一次，并正确计数。最终，我们进行的初始化 DFS 调用总数（不包括递归调用）等于岛屿的数量。

### 6、回溯

回溯只是深度优先搜索的一种扩展。在 DFS 中，我们通常会遍历一个预先构建的结构，如树或图，其中的节点和连接已经定义好。然而，在回溯中，你通常需要在探索不同选项的同时自己构建解决方案树，特别是在组合问题中，树的结构并没有明确给出，而是随着你做出决策而动态生成的。

在回溯问题中，通过做出一系列决策来探索所有可能的解决方案。每个决策代表树中的一个节点，每个潜在的决策形成一个分支。当你探索一个决策时，要么找到一个有效的解决方案，要么遇到死胡同。当某个决策导致死胡同时，你需要回溯到上一个决策点，撤销该决策，尝试另一条路径。

**模板**

```python
ans = []

def dfs(start_index, path, [...additional states]):
    if is_leaf(start_index):
        ans.append(path[:])    # add a copy of the path to the result
        return
    for edge in get_edges(start_index, [...additional states]):
        # prune if needed
        if not is_valid(edge):
            continue
        path.add(edge)
        if additional states:
            update(...additional states)
        dfs(start_index + len(edge), path, [...additional states])
        # revert(...additional states) if necessary e.g. permutations
        path.pop()

```


LeetCode(17) 上的一道题目来逐步理解它，这道题是电话号码的字母组合。在这个问题中，我们给定一个数字字符串，通常是从 2 到 9，我们需要返回这些数字可能代表的所有字母组合，使用电话键盘的映射关系。例如，如果我们有数字 23，每个数字对应一组字母，2 对应 A、B、C，3 对应 D、E、F。我们的目标是生成这些字母的所有可能组合。

因此，对于数字 23，可能的输出组合包括 AD、AE、AF、BD、BE、BF 等等。现在，我们的目标是找出所有这些组合。回溯法是解决这个问题的最佳方法，因为它允许我们逐一探索每个可能的字母，同时尽早剪枝无效的配置。与暴力枚举所有可能的组合不同，回溯法让我们能够逐个字母构建解决方案，并舍弃那些不再合理的部分路径。

我们首先获取输入的数字，并检查输入是否为空，如果为空则返回一个空列表。接着初始化一个空列表用于存储结果，并定义一个递归辅助函数 DFS 来执行深度优先搜索。DFS 函数通过起始索引跟踪当前在数字字符串中的位置，并通过逐步向路径列表中添加字母来构建组合。如果起始索引达到数字的长度，当前路径就是一个完整的组合，因此将其连接成字符串并添加到 ANDs 中。对于每个数字，函数会遍历从数字到字符字典中检索到的可能字母，将每个字母添加到路径中，并为下一个数字递归调用 DFS。在探索完一个字母后，它会通过从路径中移除最后一个字母来回溯，以探索下一个可能性。

DFS 从第一个数字开始，初始状态为 `DFS(0, [])`。当所有组合生成完毕后，算法会返回结果列表ANDs。整体时间复杂度为 $O(4^n)$，其中 $n$ 是输入数字的长度，因为每个数字最多可映射四个字母。该方法能高效探索所有可能的字母组合，并确保在生成每个组合后进行回溯，以继续探索下一个组合。

### 7、优先队列（Top K）

每当你看到与 topk、k_min 或 k_max 相关的问题时，总是会使用优先队列。优先队列最常见的实现方式称为堆。堆可以用来解决所有这些问题。堆是一种特殊类型的树，其中的元素以特定方式组织。堆有两种类型。在小根堆中，最小值始终位于顶部（即根节点），且每个父节点都比其子节点小。在大根堆中，最大值位于根节点，且每个父节点都比其子节点大。反直觉的是，我们使用小根堆来寻找最大的 $k$ 个值，而使用大根堆来寻找最小的 $k$ 个值。

假设我们想在七个数的列表 `[3, 6, 1, 5, 9, 12, 8]` 中找到三个最小的值。我们首先创建一个大小为 3 的大根堆。首先 `3` 作为根，然后 `6` 比 `3` 大，交换，`6` 为根，`3` 左，`1` 右。那么，当我们遇到第 4 个值时，如何判断是否需要添加它呢？

在最大堆中，根节点存储的是最大值。由于我们需要找出 3 个最小值，只需判断这个新值是否比之前记录的最大值更小。在本例中确实如此，因此我们移除根节点的值并添加新值。由此可见，这就是为什么寻找 $k$ 个最小值时要使用最大堆，而寻找 $k$ 个最大值时则恰恰相反。

堆之所以高效，是因为我们总是能通过根节点立即找到最大值或最小值。堆可以在 $O(1)$ 时间内快速访问最小或最大元素，插入或删除元素只需 $O(\log n)$ 时间复杂度，这两种操作都比遍历列表中的每个元素更高效。

### 8、动态规划（DP）

动态规划（DP）被公认为最难掌握的模式。这主要是因为这类问题存在许多不同的变体和细微差别。动态规划问题通常通过将解决方案分解为重叠的子问题、存储这些子问题的结果并重复利用它们以避免冗余计算来优化解法。动态规划主要有两种实现方式：自顶向下和自底向上。

在自顶向下的方法中，你从主要问题出发，递归地解决其子问题，并存储这些子问题的结果，以避免多次解决相同的子问题。这听起来可能很复杂，但实际上你已经掌握了大部分内容，因为自顶向下本质上就是在回溯的基础上增加了记忆化的步骤。记忆化不过是一个花哨的术语，用来描述一个简单的概念。这意味着将之前的函数调用结果保存在字典中，并在再次进行完全相同的调用时从中读取。

在自底向上的方法中，首先解决最小的子问题，然后利用它们的解来构建更大问题的解。与依赖递归不同，自底向上的动态规划通常涉及填充一个表格，其中每个条目代表一个较小子问题的解。你从基本情况开始，逐步计算规模逐渐增大的子问题的解，直到得到最终解。*这种方法避免了递归和记忆化的开销，通常能更高效地利用时间和空间。*

当你知道子问题之间的依赖关系并能以迭代方式构建解决方案时，通常会采用自底向上的方法。
