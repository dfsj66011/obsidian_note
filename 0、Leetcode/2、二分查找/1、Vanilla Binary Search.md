
## 直觉

二分查找是一种高效的数组搜索算法。它通过每次将搜索范围缩小一半来工作。如果你曾经在实体字典中查找过单词，那么你已经在现实生活中使用过二分查找了。让我们来看一个简单的例子：

*给定一个已排序的整数数组和一个名为 target 的整数，找到等于 target 的元素并返回其索引。如果未找到该元素，则返回 -1。*

这里的关键观察点是数组已经排序。我们随机选取数组中的一个元素并与目标进行比较。

- 如果我们恰好选中了等于目标的元素（运气真好！），那就太棒了。我们不需要再做任何工作；直接返回它的索引。
- 如果该元素比目标小，那么我们知道目标不可能在当前元素左侧的部分找到，因为左侧的所有元素甚至更小。因此，我们将当前元素及其左侧的所有元素从搜索范围中剔除。
- 如果该元素比目标大，那么我们知道目标不可能在当前元素右侧的部分找到，因为右侧的所有元素甚至更大。因此，我们将当前元素及其右侧的所有元素从搜索范围中剔除。

我们重复这个过程，直到找到目标元素。与随机选取元素不同，我们总是选择当前搜索范围内的中间元素。这样一来，每次都能排除一半的选项，并将搜索范围缩小一半。这使得我们的运行时间复杂度为$O(\log(N))$。

这个想法既可以通过迭代方式实现，也可以通过递归方式实现。然而，主要区别在于：迭代版本的二分查找使用 $O(1)$ 内存空间，而递归版本则需要 $O(\log(N))$ 的内存空间。

```python
def binary_search(arr: list[int], target: int) -> int:
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        if arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    
    return -1
```


### 何时使用二分查找

有趣的是，二分查找不仅适用于已排序的数组。只要你能通过二元决策来缩小搜索范围，就可以使用二分查找。我们将在后续模块中看到这一点。

